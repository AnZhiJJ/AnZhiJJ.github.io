<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>何为深度学习？</title>
      <link href="/sx01.html"/>
      <url>/sx01.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="深度学习的定义"><a class="markdownIt-Anchor" href="#深度学习的定义"></a> 深度学习的定义</h2><p>本文主要用</p><h2 id="与传统机器学习的对比"><a class="markdownIt-Anchor" href="#与传统机器学习的对比"></a> 与传统机器学习的对比</h2>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八节 数据的存储</title>
      <link href="/C8.html"/>
      <url>/C8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-数据类型详细介绍"><a class="markdownIt-Anchor" href="#1-数据类型详细介绍"></a> <strong>1. 数据类型详细介绍</strong></h2><p><strong>内置类型</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>    <span class="comment">//字符数据类型</span></span><br><span class="line"><span class="type">short</span>    <span class="comment">//短整型</span></span><br><span class="line"><span class="type">int</span>     <span class="comment">//整形</span></span><br><span class="line"><span class="type">long</span>    <span class="comment">//长整型</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span>  <span class="comment">//更长的整形</span></span><br><span class="line"><span class="type">float</span>    <span class="comment">//单精度浮点数</span></span><br><span class="line"><span class="type">double</span>   <span class="comment">//双精度浮点数</span></span><br></pre></td></tr></table></figure><p>int 和float都是占内存4个字节，但是在内存中存储形式不同</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/第八节 数据的存储/image-1.png" style="zoom: 67%;" /><p><strong>自定义类型（构造类型）</strong>—略，后面会讲。</p><h3 id="11-类型的基本归类"><a class="markdownIt-Anchor" href="#11-类型的基本归类"></a> 1.1 类型的基本归类：</h3><p><strong>整形家族：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span><span class="comment">//在内存中以Ascall码存储的</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span></span><br><span class="line"><span class="type">short</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> [<span class="type">int</span>]</span><br><span class="line">    <span class="type">signed</span> <span class="type">short</span> [<span class="type">int</span>]</span><br><span class="line"><span class="type">int</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span></span><br><span class="line"><span class="type">long</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> [<span class="type">int</span>]</span><br><span class="line">    <span class="type">signed</span> <span class="type">long</span> [<span class="type">int</span>]</span><br></pre></td></tr></table></figure><p><strong>浮点型家族</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span></span><br><span class="line"><span class="type">double</span></span><br></pre></td></tr></table></figure><p><strong>构造类型：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; 数组类型</span><br><span class="line">&gt; 结构体类型 <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&gt;</span> 枚举类型 <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&gt;</span> 联合类型 <span class="class"><span class="keyword">union</span></span></span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680841072601-18.png" /><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//无类型，此时在main中输入100是错误的</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        test(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-整形在内存中的存储"><a class="markdownIt-Anchor" href="#2-整形在内存中的存储"></a> <strong>2. 整形在内存中的存储：</strong></h2><h3 id="21-原码-反码-补码"><a class="markdownIt-Anchor" href="#21-原码-反码-补码"></a> <strong>2.1 原码、反码、补码</strong></h3><p>计算机中的<font color=Red><strong>整数（有符号数）</strong></font>有三种表示方法，即原码、反码和补码。</p><p>三种表示方法均有<strong>符号位和数值位</strong>两部分，符号位都是<strong>用0表示“正”，用1表示“负”</strong>，</p><p><strong>无符号数原码、反码、补码都相同</strong></p><p><strong>正数的原、反、补码都相同。</strong></p><p>而数值位<strong>负数的三种表示方法各不相同</strong>。如下：</p><table><thead><tr><th style="text-align:left"><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680842673110-7.png" align="left" /></th></tr></thead><tbody><tr><td style="text-align:left"><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680842677026-9.png" align="left" /></td></tr><tr><td style="text-align:left"><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680842682081-11.png" style="zoom:67%;" align="left"/></td></tr></tbody></table><p><strong>对于整形来说：数据存放内存中其实存放的是补码。</strong></p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680843045650-13.png" /><h3 id="22-二进制与八进制-十六进制转化规则"><a class="markdownIt-Anchor" href="#22-二进制与八进制-十六进制转化规则"></a> 2.2 二进制与八进制、十六进制转化规则</h3><p><strong>十六进制与二进制转化规则：“8421”原则，即4个二进制位构成1个十六进制位，并按照“8421”原则转化</strong></p><p><strong>八进制与二进制转化规则：“421”原则，即3个二进制位构成1个八进制位，并按照“421”原则转化</strong></p><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">20</span>;<span class="comment">//4个字节-32bit</span></span><br><span class="line">        <span class="comment">//00000000 00000000 00000000 00010100-原码</span></span><br><span class="line">        <span class="comment">//00000000 00000000 00000000 00010100-反码</span></span><br><span class="line">        <span class="comment">//00000000 00000000 00000000 00010100-补码</span></span><br><span class="line">        <span class="comment">//0X0014</span></span><br><span class="line">        <span class="type">int</span> b = <span class="number">-10</span>;</span><br><span class="line">        <span class="comment">//10000000 00000000 00000000 00001010-原码</span></span><br><span class="line">        <span class="comment">//11111111 11111111 11111111 11110101-反码</span></span><br><span class="line">        <span class="comment">//11111111 11111111 11111111 11110110-补码</span></span><br><span class="line">        <span class="comment">//0XFFFFFFF6</span></span><br><span class="line">        <span class="comment">//内存中存的是整数的补码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-大小端字节序介绍及判断"><a class="markdownIt-Anchor" href="#23-大小端字节序介绍及判断"></a> 2.3 大小端字节序介绍及判断</h3><p>对于a和b分别存储的是补码。但是我们发现存储到内存后顺序有点不对劲</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/%E7%AC%AC1%E8%8A%82-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8.png" style="zoom:50%;"/><h4 id="231-大小端介绍"><a class="markdownIt-Anchor" href="#231-大小端介绍"></a> <strong>2.3.1 大小端介绍</strong></h4><p><strong>什么大端小端：</strong></p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680844912666-16.png" /><p><strong>大端正着存数据，小端倒着存数据。</strong></p><p><em>编译器支持大端存储或者小端存储模式</em></p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680846416559-18.png" style="zoom:60%;" /><p>**例：**写一段代码告诉我们当前机器的字节序是什么？</p><p><em>char</em>类型访问一个字节的地址*</p><p><strong>//指针类型的意义：</strong></p><p>1.指针类型决定了指针解引用操作符能访问几个字节：<code>char*</code>能访问1个字节，<code>int*</code>能访问4个字节</p><p>2.指针类型决定了指针+1、-1，能加或者能减的是几个字节；<code>char*p,p+1跳过1个字节</code>；<code>int*p,p+1:跳过4个字节</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回1 小端存储</span></span><br><span class="line"><span class="comment">//返回0 大端存储</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check_sys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>*p=(<span class="type">char</span>*)&amp;a;<span class="comment">//将&amp;a类型从int*强制转换为char*,方便指针p调用</span></span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = check_sys();<span class="comment">//将&amp;a类型从int*强制转换为char*,方便指针p调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret== <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端存储\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端存储\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24-练习"><a class="markdownIt-Anchor" href="#24-练习"></a> 2.4 练习</h3><h4 id="例1"><a class="markdownIt-Anchor" href="#例1"></a> <strong>例1：</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//-1-char类型 占1个字节即8个比特位</span></span><br><span class="line">    <span class="comment">//10000001-原码</span></span><br><span class="line">    <span class="comment">//11111110-反码</span></span><br><span class="line">    <span class="comment">//11111111-补码</span></span><br><span class="line">    <span class="type">char</span> a = <span class="number">-1</span>;<span class="comment">//char-字符类型 占1个字节</span></span><br><span class="line">    <span class="comment">//11111111-补码---&gt;-1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> b = <span class="number">-1</span>;<span class="comment">//signed符号数</span></span><br><span class="line">    <span class="comment">//11111111-补码---&gt;-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">-1</span>;<span class="comment">//unsigned-无符号数</span></span><br><span class="line">    <span class="comment">//11111111-补码、原码-----&gt;255</span></span><br><span class="line">    <span class="comment">//类型提升：从有符号数(char)转换为无符号数(unsigned char)，最高位转为无符号位。</span></span><br><span class="line">    <span class="comment">//此时由于unsigned存在，整型直接将有符号位转换为无符号位</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d,c=%d&quot;</span>, a, b, c);<span class="comment">//%d-整型，此时会发生类型提升</span></span><br><span class="line">    <span class="comment">//-1 -1 255</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，变量c是一个无符号的char类型，其取值范围为0到255。当将有符号的-1赋给无符号的变量c时，<strong>由于无符号数不支持负数，编译器会先将-1转换为其对应的无符号整数表示方式</strong>，即<strong>将有符号数的补码转换为无符号数的值</strong>。</p><p>在8位(char)情况下，-1的补码为11111111，将其转换为无符号整数后，其值为2^8 - 1 = 255。因此，当用printf函数并指定格式化字符串为&quot;%d&quot;时，输出的结果为c=255，对应于二进制表示为11111111。</p><h4 id="例2"><a class="markdownIt-Anchor" href="#例2"></a> <strong>例2：</strong></h4><p><strong>//<font color=Red>类型提升：从有符号数(char)转换为无符号数（unsigned int)，补位须与最高位相同。</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">-128</span>;</span><br><span class="line">    <span class="comment">//10000000-原码</span></span><br><span class="line">    <span class="comment">//11111111-反码</span></span><br><span class="line">    <span class="comment">//10000000-补码（8位）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, a);<span class="comment">//%u-打印十进制的无符号数，</span></span><br><span class="line">    <span class="comment">//%u将a从有符号字符(char)转换为无符号数（unsigned int)，补位须与最高位相同。</span></span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 10000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char类型确实只占8位，但在这段代码中，使用**%u格式说明符时将变量a强制转换为无符号整数(unsigned int)类型。通常情况下，unsigned int类型在大多数系统架构中都是占用32位的内存空间。**</p><p>因此，当a的值为-128时，其在内存中的二进制补码表示为10000000。**按照%u格式说明符进行输出时，编译器会先将其强制转换为一个32位的无符号整数(unsigned int)，补齐高位后输出其二进制表示。**因此输出的结果为11111111 11111111 11111111 10000000的二进制表示，对应于4294967168这个十进制无符号整数。</p><h4 id="注"><a class="markdownIt-Anchor" href="#注"></a> 注：</h4><p><strong><font color=Red>signed char(有符号字符）类型范围是-128~127，超过127自动转化为-128直到转化到0，再从0开始累计</font></strong></p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680848507527-22.png" style="zoom:50%;" /><p><strong><font color='red'>unsigned char(无符号字符)类型范围是0~225，超过225自动转化为0，再开始累计</font></strong></p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680848316815-20.png" style="zoom:67%;" /><h4 id="例3"><a class="markdownIt-Anchor" href="#例3"></a> <strong>例3：</strong></h4><p><strong>//<font color='red'>signed char（有符号字符）类型最大只能存入01111111（127）当超过之后，就会变成127+1变成-128了，不溢出。</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123; <span class="type">char</span> a = <span class="number">128</span>; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, a); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//signed char（无符号字符）类型最大只能存入01111111（127）当超过之后，就会变成127+1变成-128了，不溢出。  </span></span><br></pre></td></tr></table></figure><h4 id="例4"><a class="markdownIt-Anchor" href="#例4"></a> <strong>例4：</strong></h4><p><strong>//<font color='red'>有符号和无符号一起计算时，首先按照补码的形式进行运算，最后格式化成为有符号数</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">-20</span>;</span><br><span class="line">    <span class="comment">//10000000 00000000 00000000 00010100</span></span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 11101011</span></span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 11101100-补码</span></span><br><span class="line">                                </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//00000000 00000000 00000000 00001010</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + b);</span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 11101100-a</span></span><br><span class="line">    <span class="comment">//00000000 00000000 00000000 00001010-b</span></span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 11110110-a+b---&gt;-10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例5"><a class="markdownIt-Anchor" href="#例5"></a> <strong>例5：</strong></h4><p>**//<font color='red'> unsigned int i; 其中i为无符号数，无论i含不含负数，都认为是无符号数。此时会将其补码视为无符号数真实值，即i始终大于等于0 </font>**下列代码中会陷入死循环。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, i);</span><br><span class="line">        Sleep(<span class="number">1000</span>);<span class="comment">//睡眠代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例6"><a class="markdownIt-Anchor" href="#例6"></a> 例6：</h4><p><strong>signed</strong> **char(有符号字符）的范围是-128<sub>127，当char数组存入int元素时,会将其转换为char类型**，由此，下列代码中存入到char数组的元素经历了从-1</sub>-128<sub>127</sub>0转化，而char字符0表示的是‘\0’，故最终计算字符串长度为255.</p><p><strong>注：</strong> <strong>//<font color=red>int类型占4个字节，不代表i会占4个字节！！！不要陷入误区。</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//int类型占4个字节，不代表i会占4个字节！！！</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="number">-1</span>-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">strlen</span>(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例7"><a class="markdownIt-Anchor" href="#例7"></a> 例7:</h4><p>**<font color=red>unsigned char(无符号字符）的范围是0~225，当超过225后自动转为0重新累计到225；</font>**下列代码因此陷入死循环。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;<span class="comment">//0~225</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;=<span class="number">255</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//陷入死循环</span></span><br></pre></td></tr></table></figure><h2 id="3-浮点型在内存中的存储"><a class="markdownIt-Anchor" href="#3-浮点型在内存中的存储"></a> 3. 浮点型在内存中的存储</h2><p><strong>常见的浮点数：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159</span></span><br><span class="line"><span class="number">1E10</span></span><br><span class="line">浮点数家族包括：<span class="type">float</span>、<span class="type">double</span>、<span class="type">long</span> <span class="type">double</span>类型。</span><br><span class="line">浮点数表示的范围：<span class="type">float</span>.h</span><br></pre></td></tr></table></figure><h3 id="31一个例子"><a class="markdownIt-Anchor" href="#31一个例子"></a> 3.1一个例子</h3><p>浮点数存储的例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="type">float</span> *pFloat = (<span class="type">float</span> *)&amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为：%d\n&quot;</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);</span><br><span class="line"></span><br><span class="line">    *pFloat = <span class="number">9.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num的值为：%d\n&quot;</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680849776251-24.png" style="zoom:33%;"  /><h3 id="32-浮点数存储规则"><a class="markdownIt-Anchor" href="#32-浮点数存储规则"></a> 3.2 浮点数存储规则</h3><p>根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：</p><table><thead><tr><th style="text-align:left">(-1)^S * M * 2^E                                                                                                                             (-1)^s 表示符号位，当s=0，V为正数；当s=1，V为负数。                                                         M表示有效数字，1≤M&lt;2。                                                                                                                    2^E表示指数位。</th></tr></thead></table><h5 id="ieee-754规定"><a class="markdownIt-Anchor" href="#ieee-754规定"></a> <strong>IEEE 754规定：</strong></h5><p>对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407162229299.png" style="zoom:50%;" /><p>对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407162359787.png" style="zoom:50%;" /><h5 id="ieee-754font-colorred一些特别规定font"><a class="markdownIt-Anchor" href="#ieee-754font-colorred一些特别规定font"></a> IEEE 754<font color=red>一些特别规定</font>：</h5><p><strong><font color=blue>有效数字M情况：</font></strong></p><p>**在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，<strong>等到读取的时候，再把第一位的1加上去</strong>。这样做的目的，是节省1位有效数字。<strong>以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字</strong>。</p><p><strong><font color=blue>指数E情况：</font></strong></p><div style="text-align: justify;font-size:16px;">E为一个无符号整数（unsigned int）如果E为8位，它的取值范围为0~225；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。</div><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">5.5</span>;</span><br><span class="line">    <span class="comment">//5.5---101.1</span></span><br><span class="line">    <span class="comment">//(-1)^0*1.011*2^2</span></span><br><span class="line">    <span class="comment">//S=0;M=1.011;</span></span><br><span class="line">    <span class="comment">//E=2;</span></span><br><span class="line">    <span class="comment">//S  E+127    M</span></span><br><span class="line">    <span class="comment">//0 10000001  01100000000000000000000</span></span><br><span class="line">    <span class="comment">//0100 0000 1011 0000 0000 0000 0000 0000</span></span><br><span class="line">    <span class="comment">//0X40b00000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//最终在内存里为小端存储</span></span><br></pre></td></tr></table></figure><h4 id="指数e从内存中取出分三种情况"><a class="markdownIt-Anchor" href="#指数e从内存中取出分三种情况"></a> <strong>指数E从内存中取出分三种情况</strong></h4><p><strong>1.E不全为0或不全为1</strong></p><p>这时，浮点数就采用下面的规则表示，<strong>即指数E的计算值减去127（或double类型是1023），得到真实值，再将有效数字M前加上第一位的1。</strong></p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407173256948.png" style="zoom:80%;" /><p><strong>2.E全为0(即为-127时)</strong></p><p>这时，<strong>浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数</strong>。这样做是为了表示±0以及接近于0的很小的数字</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407173856180.png" style="zoom:80%;" /><p><strong>3.E全为1</strong></p><p>这时，<strong>如果有效数字M全为0，表示±无穷大</strong>(数字很大）（正负取决于符号位s）</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407174114862.png" style="zoom:80%;" /><p><strong>解释例子（看其中解释）：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">  <span class="comment">//00000000 00000000 00000000 00001001-补码</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span>* pFloat = (<span class="type">float</span>*)&amp;n;<span class="comment">//此时*pFloat可以指向int所占的4个字节空间，但是指针只能一个字节一个字节的访问空间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;n的值：%d\n&quot;</span>, n);<span class="comment">//9</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*pfloat的值为：%f\n&quot;</span>, *pFloat);<span class="comment">//此时*pFloat会认为其n为浮点数,会对其二进制按照浮点数来排列(S E+127 M)输出</span></span><br><span class="line">  <span class="comment">//首先，将9拆分，得到第一位符号位s=0，后面8位的指数E=00000000，最后23位的有效数字M = 000 0000 0000 0000 0000</span></span><br><span class="line">  <span class="comment">//由于指数E全为0，所以符合上一节的第二种情况。因此，浮点数V就写成：</span></span><br><span class="line">  <span class="comment">//(-1)^0 * 0.00000000000000000001001 * 2^-126</span></span><br><span class="line">  <span class="comment">//V是一个很小的接近于0的正数，所以用十进制小数表示打印出来0.000000</span></span><br><span class="line"></span><br><span class="line">  *pFloat = <span class="number">9.0</span>;</span><br><span class="line">  <span class="comment">//1001.0--9.0的补码</span></span><br><span class="line">  <span class="comment">//1.001*2^3 #S=0 , M=1.001 , E=3---011</span></span><br><span class="line">  <span class="comment">//E+127---10000010</span></span><br><span class="line">  <span class="comment">// S      E+127         M(23bit)</span></span><br><span class="line">  <span class="comment">//(-1)^0 * 10000010 * 00100000000000000000000 ---浮点数在内存表现形式</span></span><br><span class="line">  <span class="comment">//0 10000010 00100000000000000000000 </span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;num的值：%d\n&quot;</span>, n);<span class="comment">//此时n将*pFloat存进去认为是整数，会对其二进制按照整数来排列输出。即</span></span><br><span class="line">  <span class="comment">//01000001 00010000 00000000 00000000</span></span><br><span class="line">  <span class="comment">//0x41 10 00 00--十六进制</span></span><br><span class="line">  <span class="comment">//1091567616--十进制</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>, *pFloat);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
