<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第九节 指针的进阶</title>
      <link href="/C9.html"/>
      <url>/C9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="指针基础"><a href="#指针基础" class="headerlink" title="指针基础"></a>指针基础</h1><p>指针的主题，我们在初级阶段的《指针》章节已经接触过了，我们知道了指针的概念：</p><blockquote><p>1.指针就是变量，是用来存地址的，地址是唯一标识一块内存空间<br>2.指针的大小是固定的4/8个字节（由平台决定，32位/64位）<br>3.指针是有类型的，通常类型有char、int 、short、long、float、double<br>4.指针类型决定了指针+-整数的步长，指针解引用操作的时候的能够访问空间的大小<br>5.指针的运算。</p><ul><li><strong>指针+-整数(==&gt;指针指向的是该地址的上一个或下一个地址）</strong></li><li><strong>指针-指针（指向同一内存空间,可得指针之间的元素个数）</strong></li><li><strong>指针的关系运算（比较地址大小）</strong></li></ul></blockquote><h1 id="字符指针"><a href="#字符指针" class="headerlink" title="字符指针"></a>字符指针</h1><p>指针类型中存在一种字符指针<code>char*</code></p><p><b>一般使用：</b></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch= <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> *pc = &amp;ch;</span><br><span class="line">    *pc =<span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>另一种使用方式：</b></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pstr = <span class="string">&quot;hello bit.&quot;</span>;<span class="comment">//这里是把一个字符串放到pstr指针变量里了吗？</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pstr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>注：</em></strong></p><blockquote><p><strong><font color=black>(一）常量指针int const* p 和 const int* p</font></strong></p><p><b><font color=red>const 放在指针变量的 * 左边时，表示该指针所指向的数据（地址内的内容）是常量，即不能通过该指针修改所指向的数据。但p所指向的地址可以变。</font></b></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">int</span> *p = &amp;num;  <span class="comment">// 将const放在*的左边，表示所指向的数据是常量</span></span><br><span class="line">&gt;*p = <span class="number">20</span>;  <span class="comment">// 编译错误，因为p所指向的数据是常量</span></span><br><span class="line">&gt;p++;     <span class="comment">// 合法，p本身不是常量</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，p 是一个指向 num的常量指针，即不能通过 p修改 num的值。但是可以通过 p 修改其指向的地址。</p><p>注<strong>：int const* p定义了一个指向 const int类型数据的指针变量 p，也就是说，p 所指向的数据是一个常量，不能通过 p修改其所指向的数据</strong>。但是 p本身不是常量，可以指向其他的 const int类型数据。</p><p><strong><font color=black>(二）指针常量int* const p</font></strong></p><p><b><font color=red>const放在指针变量的*右边时，表示指针本身是常量。它指向的地址是不可改变的，但地址里的内容可以通过指针改变。</font></b></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">&gt;<span class="type">int</span> *<span class="type">const</span> p = &amp;num;  <span class="comment">// 将const放在*的左边，并且指针本身也是常量</span></span><br><span class="line">&gt;*p = <span class="number">20</span>;   <span class="comment">// 合法，可以通过p来修改所指向的数据</span></span><br><span class="line">&gt;p++;      <span class="comment">// 编译错误，因为p本身是常量，不能修改其指向的地址</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，int* const p就是一个指针常量，表示定义了一个指向 int 类型的指针变量 p，且这个指针变量是一个常量，其值(地址）不能被改变，但它所指向的 int类型数据（地址内的内容）可以被修改。</p><p><b><font color=black>总结:</font></b></p><p>一般是根据靠近原则来看，<strong>const修饰p那么就是指针本身值（即指向的地址）不变，const修饰*p那么就是指指针指向的变量值（指向的值）不变</strong></p><p><strong><font color=red>加深记忆记住三句话：</font></strong></p><ul><li>指针和 const 谁在前先读谁 ；</li><li>*象征着地址，const象征着内容；</li><li>谁在前面<strong>谁就不允许改变。</strong></li></ul></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> arr1[] = <span class="string">&quot;abcdefk&quot;</span>;</span><br><span class="line"><span class="type">char</span> arr2[] = <span class="string">&quot;abcdefk&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p1 = <span class="string">&quot;abcdefk&quot;</span>;<span class="comment">//const使变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p2 = <span class="string">&quot;abcdefk&quot;</span>;<span class="comment">//常量字符串的地址会在内存中单独开辟一个空间，地址固定，</span></span><br><span class="line"><span class="keyword">if</span> (p1 == p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;haha\n &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if (arr1 = arr2)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;hehe\n&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;haha\n&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里p1和p2指向的是一个<b><font color=red>同一个常量字符串</font></b>。C/C++会把常量字符串存储到单独的一个内存区域，当<br>几个指针。<strong>指向同一个字符串的时候，他们实际会指向同一块内存。但是用相同的常量字符串去初始化</strong><br><strong>不同的数组的时候就会开辟出不同的内存块</strong>。所以arr11和arr2不同，p1和p2不同。  <strong>来源《剑指offer》</strong></p><h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><blockquote><h2 id="预备知识："><a href="#预备知识：" class="headerlink" title="预备知识："></a><strong>预备知识：</strong></h2><ul><li><p>1.&amp;arr-数组名-此时数组名不是首元素的地址—数组名表示整个数组—&amp;数组名 取出的是整个数组的地址。</p></li><li><p>2.sizeof(arr)-sizeof(数组名）-数组名表示整个数组-sizeof(数组名）计算的是整个数组的大小。</p></li><li><p>除1、2以外，<strong><font color=blue>数组名表示数组的首元素的地址</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span>* arr1[<span class="number">10</span>]; <span class="comment">//整形指针的数组</span></span><br><span class="line"><span class="type">char</span> *arr2[<span class="number">4</span>]; <span class="comment">//一级字符指针的数组</span></span><br><span class="line"><span class="type">char</span> **arr3[<span class="number">5</span>];<span class="comment">//二级字符指针的数组```</span></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr1[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr2[] = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr3[] = &#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> &#125;;</span><br><span class="line"><span class="type">int</span>* parr[] = &#123; arr1,arr2,arr3 &#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E4%B9%9D%E8%8A%82%20%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6/image-20230422002000521.png" alt="image-20230422002000521"></p><p><strong>指针数组用法：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr1[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr2[] = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr3[] = &#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* parr[] = &#123; arr1,arr2,arr3 &#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; <span class="number">5</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(parr[i] + j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h1><h2 id="数组指针的定义"><a href="#数组指针的定义" class="headerlink" title="数组指针的定义"></a>数组指针的定义</h2><p><strong>数组指针是指针</strong></p><blockquote><p>整形指针：int <em> pint; 能够指向整形数据的指针。<br>浮点型指针：float </em> pf; 能够指向浮点型数据的指针。<br>数组指针：能够指向数组的指针</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1[<span class="number">10</span>];<span class="comment">//==int* p1[10] 指针数组</span></span><br><span class="line"><span class="type">int</span> (*p2)[<span class="number">10</span>];<span class="comment">//数组指针</span></span><br><span class="line"><span class="comment">//p1, p2分别是什么？</span></span><br></pre></td></tr></table></figure><p><strong>指针数组</strong>，对于语句“int* p1[10]”，因为“[]”的优先级要比“*”要高，所以 p1 先与“[]”结合，构成一个数组的定义，数组名为 p1，而“int<em>”修饰的是数组的内容，即数组的每个元素。也就是说，<strong>该数组包含 10个指向 int 类型数据的指针，</strong>如图 1 所示，因此，它是<em>*一个指针数组</em></em>。</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E4%B9%9D%E8%8A%82%20%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6/22201218-19ddd896ae6a45e1b61c7e3ee59b4662.jpg" alt="Attachment">                                                       </p><p>​                                                                                                                      图 1</p><p><strong>数组指针</strong>，对于语句“int(*p2)[5]”，“()”的优先级比“[]”高，“*<strong>”号和 p2 构成一个指针的定义</strong>，<strong>指针变量名为 p2</strong>，<strong>而 int 修饰的是数组的内容，即数组的每个元素。</strong>也就是说，<strong>p2 是一个指针，它指向一个包含 10 个 int 类型数据的数组</strong>，如图 2 所示。很显然，它是一个数组指针，<strong>数组在这里并没有名字，是个匿名数组</strong>。</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E4%B9%9D%E8%8A%82%20%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6/22201218-19ddd896ae6a45e1b61c7e3ee59b4662(1" alt="Attachment">.jpg)</p><p>​                                                                                                                  图 2</p><p>由此可见，</p><blockquote><p>对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；<br>而对数组指针来说，<strong>首先它是一个指针</strong>，<strong>它指向一个数组，</strong>也就是说它是指向数组的指针，&gt;在 32 位系统下永远占 4 字节，至于它指向的数组占多少字节，这个不能够确定，要看具体情况。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//int* p = NULL;//p是整形指针 - 指向整形的指针 - 可以存放整形的地址</span></span><br><span class="line"><span class="comment">//char* pc = NULL;//pa是字符指针 - 指向字符的指针 - 可以存放字符的地址</span></span><br><span class="line">                  <span class="comment">//数组指针 - 指向数组的指针 -可以存放数组的地址</span></span><br><span class="line"><span class="comment">//int arr[10] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//arr-首元素地址</span></span><br><span class="line"><span class="comment">//&amp;arr[0]-首元素的地址</span></span><br><span class="line"><span class="comment">//&amp;arr-数组的地址(整个数组）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>] = &amp;arr;<span class="comment">//数组的地址要存起来</span></span><br><span class="line"><span class="comment">//上面的p就是数组指针</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* arr[<span class="number">5</span>];<span class="comment">//指针数组</span></span><br><span class="line"><span class="type">char</span>* (*pa)[<span class="number">5</span>]=&amp;arr;</span><br><span class="line"><span class="comment">//*pa指针指向数组5个元素，即(*pa)[5]；而指向的数组元素类型是char*。</span></span><br><span class="line">  <span class="comment">//故取数组的地址&amp;arr写成：char* (*pa)[5]=&amp;arr； </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E4%B9%9D%E8%8A%82%20%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6/image-20230422185558143.png" alt="image-20230422185558143" style="zoom:50%;" /></p><h2 id="amp-数组名VS数组名"><a href="#amp-数组名VS数组名" class="headerlink" title="&amp;数组名VS数组名"></a>&amp;数组名VS数组名</h2><p><strong><font color=red>&amp;arr是取的整个数组的地址</font></strong></p><h2 id="数组指针用法"><a href="#数组指针用法" class="headerlink" title="数组指针用法"></a>数组指针用法</h2><h3 id="用法1："><a href="#用法1：" class="headerlink" title="用法1："></a>用法1：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>(*pa)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*pa+i));<span class="comment">//*pa==arr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用法2-地址传参"><a href="#用法2-地址传参" class="headerlink" title="用法2:地址传参"></a>用法2:地址传参</h3><p><strong>二维数组看作一维数组，则其数组名就是首元素的地址</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arr[i] == *(a+i) == *(p+i) ==  p[i]</span><br><span class="line">  </span><br><span class="line">*(*(p + i) + j)== *(p[i] + j)==(*(p + i))[j]==p[i][j]</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*(p + i) + j);<span class="comment">//(p + i)找到n维数组第i行的地址，(*(p + i) + j)找到n维数组第i行的第j列元素的地址</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是数组的形式</span></span><br><span class="line"><span class="comment">//void print1(int arr[3][5], int x, int y)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">////int i = 0, j = 0;</span></span><br><span class="line"><span class="comment">////for (i = 0;i &lt; x;i++)</span></span><br><span class="line"><span class="comment">////&#123;</span></span><br><span class="line"><span class="comment">////for (j = 0;j &lt; y;j++)</span></span><br><span class="line"><span class="comment">////&#123;</span></span><br><span class="line"><span class="comment">////printf(&quot;%d &quot;, arr[i][j]);</span></span><br><span class="line"><span class="comment">////&#125;</span></span><br><span class="line"><span class="comment">////printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">////&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是指针的形式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> (*p)[<span class="number">5</span>], <span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//int (*p)[5] - 数组指针p是指向含5个元素为int类型的数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; x;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; y;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i][j]);</span><br><span class="line"><span class="comment">//printf(&quot;%d &quot;, *(p[i] + j));</span></span><br><span class="line"><span class="comment">//printf(&quot;%d &quot;, * (*(p + i) + j));//(p + i)找到n维数组第i行的地址，(*(p + i) + j)找到n维数组第i行的第j列元素的地址</span></span><br><span class="line"><span class="comment">//printf(&quot;%d &quot;, (*(p + i))[j]);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br><span class="line"><span class="comment">//print1(arr, 3, 5);//arr - 数组名 -数组名就是首元素的地址</span></span><br><span class="line">print2(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//数组名arr，表示首元素的地址</span></span><br><span class="line">    <span class="comment">//但是二维数组的首元素是二维数组的第一行</span></span><br><span class="line">    <span class="comment">//所以这里传递的arr，其实相当于第一行的地址，是一维数组的地址</span></span><br><span class="line">    <span class="comment">//可以数组指针来接收</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//int arr[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;</span></span><br><span class="line"><span class="comment">//int i = 0;</span></span><br><span class="line"><span class="comment">//int* p = arr;</span></span><br><span class="line"><span class="comment">//for (i = 0;i &lt; 10;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">////printf(&quot;%d &quot;, *(p + i));</span></span><br><span class="line"><span class="comment">////printf(&quot;%d &quot;,p[i]);</span></span><br><span class="line"><span class="comment">////printf(&quot;%d &quot;, *(arr + i));</span></span><br><span class="line"><span class="comment">//printf(&quot;%d &quot;, arr[i]);//arr[i] == *(a+i) == *(p+i) ==  p[i]</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];<span class="comment">//arr是一个含5个元素的整形数组</span></span><br><span class="line"><span class="type">int</span> *parr1[<span class="number">10</span>];<span class="comment">//parr1是一个数组，数组有10个元素，每个元素的类型是int*,故parr1是指针数组</span></span><br><span class="line"><span class="type">int</span> (*parr2)[<span class="number">10</span>];<span class="comment">//parr2是数组指针，它指向一个含10个元素的数组，数组的元素类型是int</span></span><br><span class="line"><span class="type">int</span> (*parr3[<span class="number">10</span>])[<span class="number">5</span>];<span class="comment">//parr3是数组，该数组的有10个元素，每个元素是一个数组指针；该数组指针指向的数组有5个元素，每个元素类型是int</span></span><br></pre></td></tr></table></figure><h2 id="数组参数、指针参数"><a href="#数组参数、指针参数" class="headerlink" title="数组参数、指针参数"></a>数组参数、指针参数</h2><h3 id="一维数组传参"><a href="#一维数组传参" class="headerlink" title="一维数组传参"></a>一维数组传参</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[])</span><span class="comment">//ok</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[<span class="number">10</span>])</span><span class="comment">//ok</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> *arr)</span><span class="comment">//ok</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> *arr[<span class="number">20</span>])</span><span class="comment">//ok</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> **arr)</span><span class="comment">//ok//一级指针的地址存放在二级指针里 int **arr</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *arr2[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">    test2(arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组传参"><a href="#二维数组传参" class="headerlink" title="二维数组传参"></a>二维数组传参</h3><p><strong>二维数组的数组名是首元素的地址，传参时，传入的是<font color=red>数组第一行地址</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>])</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> arr[][<span class="number">5</span>])</span><span class="comment">//数组传参，行可以省略，列不可以省略</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> arr[][])</span><span class="comment">//error</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test3</span><span class="params">(<span class="type">int</span> *arr)</span><span class="comment">//error,二维数组无法存放整形指针中去</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test4</span><span class="params">(<span class="type">int</span>** arr)</span><span class="comment">//error,数组名是第一行地址，而二级指针存放是一级变量（指针）的地址</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">//总结：二维数组传参，函数形参的设计只能省略第一个[]的数字。</span></span><br><span class="line"><span class="comment">//因为对一个二维数组，可以不知道有多少行，但是必须知道一行多少元素。</span></span><br><span class="line"><span class="comment">//这样才方便运算。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test5</span><span class="params">(<span class="type">int</span>* arr[<span class="number">5</span>])</span><span class="comment">//ok？//error</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test6</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">5</span>])</span><span class="comment">//ok？//ok</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一级指针传参"><a href="#一级指针传参" class="headerlink" title="一级指针传参"></a>一级指针传参</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = arr;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//一级指针p，传给函数</span></span><br><span class="line">    print(p, sz);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考：</strong></p><blockquote><p>当一个函数的参数部分为一级指针的时候，函数能接收什么参数？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> *p)</span></span><br><span class="line">  &#123;&#125;</span><br><span class="line"><span class="comment">//test1函数能接收什么参数？  test1(&amp;a);或test1(p1);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span>* p1=&amp;a;</span><br><span class="line">  test1(&amp;a);</span><br><span class="line">  test1(p1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">char</span>* p)</span></span><br><span class="line">   &#123;&#125;</span><br><span class="line"><span class="comment">//test2函数能接收什么参数？  test2(&amp;ch);或test2(str);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; <span class="type">char</span> ch=<span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">  <span class="type">char</span>* str=&amp;ch;</span><br><span class="line">  test2(&amp;ch);</span><br><span class="line">  test2(str);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="二级指针传参"><a href="#二级指针传参" class="headerlink" title="二级指针传参"></a>二级指针传参</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>** ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, **ptr);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;n;</span><br><span class="line">    <span class="type">int</span> **pp = &amp;p;<span class="comment">//取一级指针p的地址</span></span><br><span class="line">    test(pp);</span><br><span class="line">    test(&amp;p);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span>* arr[<span class="number">10</span>];<span class="comment">//指针数组，数组里每个元素都是一级指针</span></span><br><span class="line">  test(arr);<span class="comment">//传过去的是arr数组首元素的地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：</p><blockquote><p>当函数的参数为二级指针的时候，可以接收什么参数？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> **p)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="type">char</span> c = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">   <span class="type">char</span>*pc = &amp;c;</span><br><span class="line">   <span class="type">char</span>**ppc = &amp;pc;</span><br><span class="line">   <span class="type">char</span>* arr[<span class="number">10</span>];<span class="comment">//指针数组，数组里每个元素都是一级指针</span></span><br><span class="line">   test(&amp;pc);</span><br><span class="line">   test(ppc);</span><br><span class="line">   test(arr);<span class="comment">//Ok?//ok//传过去的是arr数组首元素的地址</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p><strong>&amp;函数名 和 函数名 都是函数的地址</strong></p><p>函数指针定义示例：</p><pre><code>int Add(int x, int y)&#123;&#125;int (*pa)(int ,int ) = Add;printf(&quot;%d\n&quot;, (*pa)(2, 3));</code></pre><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数指针 - 是指向函数的指针 -存放函数地址的指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> z = x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">/*printf(&quot;%d &quot;, Add(a, b));*/</span></span><br><span class="line"><span class="comment">//&amp;函数名 和 函数名 都是函数的地址</span></span><br><span class="line"><span class="comment">//printf(&quot;%p\n&quot;, &amp;Add);//打印出函数的地址</span></span><br><span class="line"><span class="comment">//printf(&quot;%p\n&quot;, Add);//打印出函数的地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*pa)(<span class="type">int</span> ,<span class="type">int</span> ) = Add;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*pa)(<span class="number">2</span>, <span class="number">3</span>));<span class="comment">//5</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> (*p)(<span class="type">char</span>*) = Print;</span><br><span class="line">(*p)(<span class="string">&quot;hello bit&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>课件：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面pfun1和pfun2哪个有能力存放test函数的地址？</span></span><br><span class="line"><span class="type">void</span> (*pfun1)();</span><br><span class="line"><span class="comment">//pfun1可以存放。pfun1先和*结合，说明pfun1是指针，指针指向的是一个函数，指向的函数无参数，返回值类型为void。</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pfun2</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//pfun2表明这是一个函数，其返回类型是void*</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八节 数据的存储</title>
      <link href="/C8.html"/>
      <url>/C8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数据类型详细介绍"><a href="#数据类型详细介绍" class="headerlink" title="数据类型详细介绍"></a>数据类型详细介绍</h2><p><strong>内置类型</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>    <span class="comment">//字符数据类型</span></span><br><span class="line"><span class="type">short</span>    <span class="comment">//短整型</span></span><br><span class="line"><span class="type">int</span>     <span class="comment">//整形</span></span><br><span class="line"><span class="type">long</span>    <span class="comment">//长整型</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span>  <span class="comment">//更长的整形</span></span><br><span class="line"><span class="type">float</span>    <span class="comment">//单精度浮点数</span></span><br><span class="line"><span class="type">double</span>   <span class="comment">//双精度浮点数</span></span><br></pre></td></tr></table></figure><p>int 和float都是占内存4个字节，但是在内存中存储形式不同</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/第八节 数据的存储/image-1.png" style="zoom: 67%;" /></p><p><strong>自定义类型（构造类型）</strong>—略，后面会讲。</p><h3 id="类型的基本归类："><a href="#类型的基本归类：" class="headerlink" title="类型的基本归类："></a>类型的基本归类：</h3><p><strong>整形家族：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span><span class="comment">//在内存中以Ascall码存储的</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span></span><br><span class="line"><span class="type">short</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> [<span class="type">int</span>]</span><br><span class="line">    <span class="type">signed</span> <span class="type">short</span> [<span class="type">int</span>]</span><br><span class="line"><span class="type">int</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span></span><br><span class="line"><span class="type">long</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> [<span class="type">int</span>]</span><br><span class="line">    <span class="type">signed</span> <span class="type">long</span> [<span class="type">int</span>]</span><br></pre></td></tr></table></figure><p><strong>浮点型家族</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span></span><br><span class="line"><span class="type">double</span></span><br></pre></td></tr></table></figure><p><strong>构造类型：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; 数组类型</span><br><span class="line">&gt; 结构体类型 <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&gt;</span> 枚举类型 <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&gt;</span> 联合类型 <span class="class"><span class="keyword">union</span></span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680841072601-18.png" /></p><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//无类型，此时在main中输入100是错误的</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        test(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整形在内存中的存储："><a href="#整形在内存中的存储：" class="headerlink" title="整形在内存中的存储："></a>整形在内存中的存储：</h2><h3 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h3><p>计算机中的<font color=Red><strong>整数（有符号数）</strong></font>有三种表示方法，即原码、反码和补码。</p><p>三种表示方法均有<strong>符号位和数值位</strong>两部分，符号位都是<strong>用0表示“正”，用1表示“负”</strong>，</p><p><strong>无符号数原码、反码、补码都相同</strong></p><p><strong>正数的原、反、补码都相同。</strong></p><p>而数值位<strong>负数的三种表示方法各不相同</strong>。如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680842673110-7.png" align="left" /></th></tr></thead><tbody><tr><td style="text-align:left"><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680842677026-9.png" align="left" /></td></tr><tr><td style="text-align:left"><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680842682081-11.png" style="zoom:67%;" align="left"/></td></tr></tbody></table></div><p><strong>对于整形来说：数据存放内存中其实存放的是补码。</strong></p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680843045650-13.png" /></p><h3 id="二进制与八进制、十六进制转化规则"><a href="#二进制与八进制、十六进制转化规则" class="headerlink" title="二进制与八进制、十六进制转化规则"></a>二进制与八进制、十六进制转化规则</h3><p><strong>十六进制与二进制转化规则：“8421”原则，即4个二进制位构成1个十六进制位，并按照“8421”原则转化</strong></p><p><strong>八进制与二进制转化规则：“421”原则，即3个二进制位构成1个八进制位，并按照“421”原则转化</strong></p><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">20</span>;<span class="comment">//4个字节-32bit</span></span><br><span class="line">        <span class="comment">//00000000 00000000 00000000 00010100-原码</span></span><br><span class="line">        <span class="comment">//00000000 00000000 00000000 00010100-反码</span></span><br><span class="line">        <span class="comment">//00000000 00000000 00000000 00010100-补码</span></span><br><span class="line">        <span class="comment">//0X0014</span></span><br><span class="line">        <span class="type">int</span> b = <span class="number">-10</span>;</span><br><span class="line">        <span class="comment">//10000000 00000000 00000000 00001010-原码</span></span><br><span class="line">        <span class="comment">//11111111 11111111 11111111 11110101-反码</span></span><br><span class="line">        <span class="comment">//11111111 11111111 11111111 11110110-补码</span></span><br><span class="line">        <span class="comment">//0XFFFFFFF6</span></span><br><span class="line">        <span class="comment">//内存中存的是整数的补码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大小端字节序介绍及判断"><a href="#大小端字节序介绍及判断" class="headerlink" title="大小端字节序介绍及判断"></a>大小端字节序介绍及判断</h3><p>对于a和b分别存储的是补码。但是我们发现存储到内存后顺序有点不对劲</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/%E7%AC%AC1%E8%8A%82-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8.png" style="zoom:50%;"/></p><h4 id="大小端介绍"><a href="#大小端介绍" class="headerlink" title="大小端介绍"></a>大小端介绍</h4><p> <strong>什么大端小端：</strong></p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680844912666-16.png" /></p><p><strong>大端正着存数据，小端倒着存数据。</strong></p><p><em>编译器支持大端存储或者小端存储模式</em></p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680846416559-18.png" style="zoom:60%;" /></p><p><strong>例：</strong>写一段代码告诉我们当前机器的字节序是什么？</p><p><em>char</em>类型访问一个字节的地址*</p><p><strong>//指针类型的意义：</strong></p><p>1.指针类型决定了指针解引用操作符能访问几个字节：<code>char*</code>能访问1个字节，<code>int*</code>能访问4个字节</p><p>2.指针类型决定了指针+1、-1，能加或者能减的是几个字节；<code>char*p,p+1跳过1个字节</code>；<code>int*p,p+1:跳过4个字节</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回1 小端存储</span></span><br><span class="line"><span class="comment">//返回0 大端存储</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check_sys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>*p=(<span class="type">char</span>*)&amp;a;<span class="comment">//将&amp;a类型从int*强制转换为char*,方便指针p调用</span></span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = check_sys();<span class="comment">//将&amp;a类型从int*强制转换为char*,方便指针p调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret== <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端存储\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端存储\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="例1："><a href="#例1：" class="headerlink" title="例1："></a><strong>例1：</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//-1-char类型 占1个字节即8个比特位</span></span><br><span class="line">    <span class="comment">//10000001-原码</span></span><br><span class="line">    <span class="comment">//11111110-反码</span></span><br><span class="line">    <span class="comment">//11111111-补码</span></span><br><span class="line">    <span class="type">char</span> a = <span class="number">-1</span>;<span class="comment">//char-字符类型 占1个字节</span></span><br><span class="line">    <span class="comment">//11111111-补码---&gt;-1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> b = <span class="number">-1</span>;<span class="comment">//signed符号数</span></span><br><span class="line">    <span class="comment">//11111111-补码---&gt;-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">-1</span>;<span class="comment">//unsigned-无符号数</span></span><br><span class="line">    <span class="comment">//11111111-补码、原码-----&gt;255</span></span><br><span class="line">    <span class="comment">//类型提升：从有符号数(char)转换为无符号数(unsigned char)，最高位转为无符号位。</span></span><br><span class="line">    <span class="comment">//此时由于unsigned存在，整型直接将有符号位转换为无符号位</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d,c=%d&quot;</span>, a, b, c);<span class="comment">//%d-整型，此时会发生类型提升</span></span><br><span class="line">    <span class="comment">//-1 -1 255</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，变量c是一个无符号的char类型，其取值范围为0到255。当将有符号的-1赋给无符号的变量c时，<strong>由于无符号数不支持负数，编译器会先将-1转换为其对应的无符号整数表示方式</strong>，即<strong>将有符号数的补码转换为无符号数的值</strong>。</p><p>在8位(char)情况下，-1的补码为11111111，将其转换为无符号整数后，其值为2^8 - 1 = 255。因此，当用printf函数并指定格式化字符串为”%d”时，输出的结果为c=255，对应于二进制表示为11111111。</p><h4 id="例2："><a href="#例2：" class="headerlink" title="例2："></a><strong>例2：</strong></h4><p><strong>//<font color=Red>类型提升：从有符号数(char)转换为无符号数（unsigned int)，补位须与最高位相同。</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">-128</span>;</span><br><span class="line">    <span class="comment">//10000000-原码</span></span><br><span class="line">    <span class="comment">//11111111-反码</span></span><br><span class="line">    <span class="comment">//10000000-补码（8位）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, a);<span class="comment">//%u-打印十进制的无符号数，</span></span><br><span class="line">    <span class="comment">//%u将a从有符号字符(char)转换为无符号数（unsigned int)，补位须与最高位相同。</span></span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 10000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char类型确实只占8位，但在这段代码中，使用<strong>%u格式说明符时将变量a强制转换为无符号整数(unsigned int)类型。通常情况下，unsigned int类型在大多数系统架构中都是占用32位的内存空间。</strong></p><p>因此，当a的值为-128时，其在内存中的二进制补码表示为10000000。<strong>按照%u格式说明符进行输出时，编译器会先将其强制转换为一个32位的无符号整数(unsigned int)，补齐高位后输出其二进制表示。</strong>因此输出的结果为11111111 11111111 11111111 10000000的二进制表示，对应于4294967168这个十进制无符号整数。</p><h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><p><strong><font color=Red>signed char(有符号字符）类型范围是-128~127，超过127自动转化为-128直到转化到0，再从0开始累计</font></strong></p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680848507527-22.png" style="zoom:50%;" /></p><p><strong><font color='red'>unsigned char(无符号字符)类型范围是0~225，超过225自动转化为0，再开始累计</font></strong></p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680848316815-20.png" style="zoom:67%;" /></p><h4 id="例3："><a href="#例3：" class="headerlink" title="例3："></a><strong>例3：</strong></h4><p><strong>//<font color='red'>signed char（有符号字符）类型最大只能存入01111111（127）当超过之后，就会变成127+1变成-128了，不溢出。</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123; <span class="type">char</span> a = <span class="number">128</span>; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, a); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//signed char（无符号字符）类型最大只能存入01111111（127）当超过之后，就会变成127+1变成-128了，不溢出。  </span></span><br></pre></td></tr></table></figure><h4 id="例4："><a href="#例4：" class="headerlink" title="例4："></a><strong>例4：</strong></h4><p><strong>//<font color='red'>有符号和无符号一起计算时，首先按照补码的形式进行运算，最后格式化成为有符号数</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">-20</span>;</span><br><span class="line">    <span class="comment">//10000000 00000000 00000000 00010100</span></span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 11101011</span></span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 11101100-补码</span></span><br><span class="line">                                </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//00000000 00000000 00000000 00001010</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + b);</span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 11101100-a</span></span><br><span class="line">    <span class="comment">//00000000 00000000 00000000 00001010-b</span></span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 11110110-a+b---&gt;-10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例5："><a href="#例5：" class="headerlink" title="例5："></a><strong>例5：</strong></h4><p><strong>//<font color='red'> unsigned int i; 其中i为无符号数，无论i含不含负数，都认为是无符号数。此时会将其补码视为无符号数真实值，即i始终大于等于0 </font></strong>下列代码中会陷入死循环。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, i);</span><br><span class="line">        Sleep(<span class="number">1000</span>);<span class="comment">//睡眠代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例6："><a href="#例6：" class="headerlink" title="例6："></a>例6：</h4><p><strong>signed</strong> <strong>char(有符号字符）的范围是-128~127，当char数组存入int元素时,会将其转换为char类型</strong>，由此，下列代码中存入到char数组的元素经历了从-1~-128~127~0转化，而char字符0表示的是‘\0’，故最终计算字符串长度为255.</p><p><strong>注：</strong> <strong>//<font color=red>int类型占4个字节，不代表i会占4个字节！！！不要陷入误区。</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//int类型占4个字节，不代表i会占4个字节！！！</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="number">-1</span>-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">strlen</span>(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例7"><a href="#例7" class="headerlink" title="例7:"></a>例7:</h4><p><strong><font color=red>unsigned char(无符号字符）的范围是0~225，当超过225后自动转为0重新累计到225；</font></strong>下列代码因此陷入死循环。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;<span class="comment">//0~225</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;=<span class="number">255</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//陷入死循环</span></span><br></pre></td></tr></table></figure><h2 id="浮点型在内存中的存储"><a href="#浮点型在内存中的存储" class="headerlink" title="浮点型在内存中的存储"></a>浮点型在内存中的存储</h2><p><strong>常见的浮点数：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159</span></span><br><span class="line"><span class="number">1E10</span></span><br><span class="line">浮点数家族包括：<span class="type">float</span>、<span class="type">double</span>、<span class="type">long</span> <span class="type">double</span>类型。</span><br><span class="line">浮点数表示的范围：<span class="type">float</span>.h</span><br></pre></td></tr></table></figure><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>浮点数存储的例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="type">float</span> *pFloat = (<span class="type">float</span> *)&amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为：%d\n&quot;</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);</span><br><span class="line"></span><br><span class="line">    *pFloat = <span class="number">9.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num的值为：%d\n&quot;</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680849776251-24.png" style="zoom:33%;"  /></p><h3 id="浮点数存储规则"><a href="#浮点数存储规则" class="headerlink" title="浮点数存储规则"></a>浮点数存储规则</h3><p>根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：</p><div class="table-container"><table><thead><tr><th style="text-align:left">(-1)^S <em> M </em> 2^E                                                                                                                             (-1)^s 表示符号位，当s=0，V为正数；当s=1，V为负数。                                                         M表示有效数字，1≤M&lt;2。                                                                                                                    2^E表示指数位。</th></tr></thead><tbody><tr><td style="text-align:left"></td></tr></tbody></table></div><h5 id="IEEE-754规定："><a href="#IEEE-754规定：" class="headerlink" title="IEEE 754规定："></a>IEEE 754规定：</h5><p>对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407162229299.png" style="zoom:50%;" /></p><p>对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407162359787.png" style="zoom:50%;" /></p><h5 id="IEEE-754一些特别规定："><a href="#IEEE-754一些特别规定：" class="headerlink" title="IEEE 754一些特别规定："></a>IEEE 754<font color=red>一些特别规定</font>：</h5><p><strong><font color=blue>有效数字M情况：</font></strong></p><p><strong>在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，</strong>等到读取的时候，再把第一位的1加上去<strong>。这样做的目的，是节省1位有效数字。</strong>以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字**。</p><p><strong><font color=blue>指数E情况：</font></strong></p><div style="text-align: justify;font-size:16px;">E为一个无符号整数（unsigned int）如果E为8位，它的取值范围为0~225；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。</div><p><strong>例：</strong> </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">5.5</span>;</span><br><span class="line">    <span class="comment">//5.5---101.1</span></span><br><span class="line">    <span class="comment">//(-1)^0*1.011*2^2</span></span><br><span class="line">    <span class="comment">//S=0;M=1.011;</span></span><br><span class="line">    <span class="comment">//E=2;</span></span><br><span class="line">    <span class="comment">//S  E+127    M</span></span><br><span class="line">    <span class="comment">//0 10000001  01100000000000000000000</span></span><br><span class="line">    <span class="comment">//0100 0000 1011 0000 0000 0000 0000 0000</span></span><br><span class="line">    <span class="comment">//0X40b00000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//最终在内存里为小端存储</span></span><br></pre></td></tr></table></figure><h4 id="指数E从内存中取出分三种情况"><a href="#指数E从内存中取出分三种情况" class="headerlink" title="指数E从内存中取出分三种情况"></a>指数E从内存中取出分三种情况</h4><p><strong>1.E不全为0或不全为1</strong></p><p>这时，浮点数就采用下面的规则表示，<strong>即指数E的计算值减去127（或double类型是1023），得到真实值，再将有效数字M前加上第一位的1。</strong></p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407173256948.png" style="zoom:80%;" /></p><p><strong>2.E全为0(即为-127时)</strong></p><p>这时，<strong>浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数</strong>。这样做是为了表示±0以及接近于0的很小的数字</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407173856180.png" style="zoom:80%;" /></p><p><strong>3.E全为1</strong></p><p>这时，<strong>如果有效数字M全为0，表示±无穷大</strong>(数字很大）（正负取决于符号位s）</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407174114862.png" style="zoom:80%;" /></p><p><strong>解释例子（看其中解释）：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">  <span class="comment">//00000000 00000000 00000000 00001001-补码</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span>* pFloat = (<span class="type">float</span>*)&amp;n;<span class="comment">//此时*pFloat可以指向int所占的4个字节空间，但是指针只能一个字节一个字节的访问空间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;n的值：%d\n&quot;</span>, n);<span class="comment">//9</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*pfloat的值为：%f\n&quot;</span>, *pFloat);<span class="comment">//此时*pFloat会认为其n为浮点数,会对其二进制按照浮点数来排列(S E+127 M)输出</span></span><br><span class="line">  <span class="comment">//首先，将9拆分，得到第一位符号位s=0，后面8位的指数E=00000000，最后23位的有效数字M = 000 0000 0000 0000 0000</span></span><br><span class="line">  <span class="comment">//由于指数E全为0，所以符合上一节的第二种情况。因此，浮点数V就写成：</span></span><br><span class="line">  <span class="comment">//(-1)^0 * 0.00000000000000000001001 * 2^-126</span></span><br><span class="line">  <span class="comment">//V是一个很小的接近于0的正数，所以用十进制小数表示打印出来0.000000</span></span><br><span class="line"></span><br><span class="line">  *pFloat = <span class="number">9.0</span>;</span><br><span class="line">  <span class="comment">//1001.0--9.0的补码</span></span><br><span class="line">  <span class="comment">//1.001*2^3 #S=0 , M=1.001 , E=3---011</span></span><br><span class="line">  <span class="comment">//E+127---10000010</span></span><br><span class="line">  <span class="comment">// S      E+127         M(23bit)</span></span><br><span class="line">  <span class="comment">//(-1)^0 * 10000010 * 00100000000000000000000 ---浮点数在内存表现形式</span></span><br><span class="line">  <span class="comment">//0 10000010 00100000000000000000000 </span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;num的值：%d\n&quot;</span>, n);<span class="comment">//此时n将*pFloat存进去认为是整数，会对其二进制按照整数来排列输出。即</span></span><br><span class="line">  <span class="comment">//01000001 00010000 00000000 00000000</span></span><br><span class="line">  <span class="comment">//0x41 10 00 00--十六进制</span></span><br><span class="line">  <span class="comment">//1091567616--十进制</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>, *pFloat);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
