<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Namesilo与Vercel域名配置</title>
      <link href="/techdoc2.html"/>
      <url>/techdoc2.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="19bd53ceae84148b5a697ea62f0b357f06966df6452d54aa05393290e06f5d13">99b31b6368a5aaab8697df1cede80057ed72ced6d35b24de9e79643f0ca7c723ea2d21809e968cb9c3badb39b867b0b7f2ecd54c243e22ecc5cfd3e2c85eade64572bf26d0c0dc1832e2331c2e0c24bc456598f4d70d6036ac1a95ed027bcdd833c01a35f93daa2c7b98e42228a589ccb68d3f4290d7faad643c9efa56534dcbf38c700aa3fed80ce8a95d9e3b8e277ce941d6615648e580ab5947ddc0b72f7b2e7a3bf083a3b4f70dc7c4bb803aac854ab70afd6b611b01faebc3195d38d0ec2df39ac8078501045a6126e22a05f88c1b76ac8a6a8627e0560d811e8d37114d9d13ade81e7bfa7a5fb22dc8c7d0d3a52b9bbc105e5cc09a6f481cf6cf84d2fae8de0b6d4f0ea5ff9e887b5f0b5fb8547aa36777b8477ef3f5d58f683f7125628e676b7bfbf6e23f1d796fef9171f1d09b9267175790ed8934975da28f8d0e3d95726c2192218f8a4e4297afcf9149bfd29be195cd9eba9bc345ba6d33abb99219f3fa58cea989251448a4ac7f17eb739972246622721c32fe0ae83049d036a7cde9208a800dafeb043630c9ff31a10b2f96c1cdc618ea5c79cf84a188230582b6b6bbcd5900d2b486da8aacde8d315da683812ba5e5ddf2a559740650b31dd53701557c31a5ad3649640da9ca586d489c5f9cd66072df7412d2f12b894aaf26c1e932f2ccd170a00f85ee81ce3ed34d9554a3756983668e8816bec732709d032f70d77a0288037532f526f9f13963f87b2fff70e548bcfb734345719a8e1089fb413d47ee2ebb1a84585fee7402e135a38f1fd2d481344187cc057ca18fe5382a38482360cb83638630a3c74927784d5ee16d556054b0c70bea791bee8cb5a8bc15d828ef8ec2f6355f2b5e9a3397616f687522ed8f8eebbd16006b51e52648a8c3b935abca4cd47e35456d12e08e3dd22b09fbb9974ce505cbb1f5bc3ddfe07fefef73569d704e6b5fcd01644d40aa91b0ad3a6acfc8282e47407861eb7ed8adfdda054e40b2f4f4ee8502f99b5aff068a5cf1ceda33e5d7463d378a2a6ddefc198d19e2de0c2d914543ab352d0529e4049483490873959cde1d6937c752ec245d6a422e390c733abb9a251e620242f5a350c584a1140cda59fc1c04ce5147a960252984e49b6f2ddc08c615a3b76f3dc2e0c7601060839272d30a59c839503c6b44fe276c703ce0c103ed9334fbdc0e438ca6065cce4736a7cb72254fad300b65462524ea55e46ab1df59ce1a503ab9f29ec00ffa3c88868ba14c4a433bfef539ac2f82bbaa62c8b70408c493e7c493a68f414e9fd45391eb6714c52b8866a99b036fffed84523b6a739c2bbaa6a6e3513f29659d7d9381a7527ee88d8289f7fb46d7110337a4b38d7b28df9d379c509bdc3ae8e13e3cd3a9469e66cd894de90f84afada166f1ae2b384621ea25e7e0c81d040533b6968f29b45b2c2d6866b80a1f606028008facb9efb68c02bb8c301534b9177af7ca9d42d8abca60f1b243fe0cc884c574219ff31a18e44d332b21cfe94a134212c6bbcc567f2ea3da6b84c15f5190b72127bc9abe1d8097e6a1d299d69f70625954d8018c32f0f3857650860a2b11024dc2ef47f94e214e28d92ca206ee192bd0ceb732b53bf3c276bda4f4c1ad308e057b6661341403019c11738614b8d46a2775c17960f7e9b6c58e35021e222bd1f027eb8d652dc0717bf196770650a8b3a4f0eefa31fc0fe707795fc584aa5fe4ed5dfcbe87c4c8a6005db913a7fca8a9f0faa054f9ab549ce9e2e14d3c0bb636f0dc17b514f3507a2753e71f63b9f6e33dce9b9878d891faf7567ff6f254795f92d44d000f57092cf287b1dac6af9268aee0a014f7b7034424e7bf43c62507fad5047b59b9f4248bb795bc93f537f4134239b94946f96a85d10507dc6d670094445489d031f321de59e17b22fdccbcaa46a718c57f90e930b22a8dc0923dd9847c4b40845a41fbecb52b5a0e20a70cb1cd39b892d03e28194a1936981bc47c52146c33caef2a45c8f50f9b8a3d5c19b653fd0c95ff176b793e56d1083255dd63141e68367a2651825806417eafccf275179952afab4d3b8f2fac89fafd0e5c4a6b192b7e86fd101d0d57833d5d7505ae6bf3beea91dbb62c03504a069d8e31969677a117f178e669d5ce95ae7139d789775c5c62af680cb0a906a2987eea4e34e037eec48a7e892350cde1365a89f767bf73b38b17e5c50a66459cc1b68bc1549c53a25d117e92a5591f7918364c0c3dac0e1eddb3d0aede4223bb1f73d9bd9f66165cc50692eda8e4cac9112a8604c1c7e016616a8f9a6e3e426abe0d04e4b2bcc4952343d880ca19e117c3d5b4fe3e952f5122f5a63554766d9b1c711ad3f6b89e0417394c7517c5945be890cbd7f8b85c94c9c43ae5edf241fc4e37d8090fe7389c429df05771029f8f965ca90266938ee0a2ca53c18b95dbd737d397510dc348d178ee9ccdd0a7938e542947ae178cfc851e37a19d2abe90520cbb5f6505d19ddc24dd625677c64215c663e98daef907e96c1d68baa884d05707d5f64d44a098d138cd47520d99e4dfd94397f9e519312cb33372d65260de68ba9a84af4e51649367dcff85c35d2c7da1dacb5607657eba151037b5bc8154244f657b6ec26f6dae5735fdda8d7ebd764d17577debd86b84f9fcdafda97d97580a01002f8ba0fd4ab586a215552bd3c1303a5d8fe845a4cedbcb8db78c1cb35849b1b45e0edaef48e9148ff3e5a19d9132f9cad13a5e0f29de5dd972b80da0a0f5167462dc7f421579ad078e9fcd5438e61968d0805540ddcdef7cce07f79b3b2a5aef9728f1f582bb5a5f1cb315367a68d456a8eddf48f49d98ddd5472a69819782c6d9142753385122f2902750b50c132b51bec6fa39dbc63489a51c707e3e512959d99ba3c2950a2685a80fbada542fa680b7153b773a788f1a3dd3dd904c732761e4a90e5c9f2497a320377bd5dc9413bac93408820494e499a26754095d6d6e5fad8e8a350232c60d2e2191cc4e476a8bdda4ca081fbb132c077ddc1c29756ec4b055a7c4cd3397399ba6775b024562ac0b96e1d5fea221ea6a14a9e6d8f3defdcc06e8a53857602a8a88e254e3f4e16ca2510bd4a2dd86f2f10a0e6e971df3ed2511d33dc852590b1880531a37bceb7e201738903bd5137b6f767490d4faa826328fbd3a6da1ca3aa47aec2f49ace2a25f337020747517a869251bacaf2797a52df12186a1f3751c878e2120805f72f41bd217da509e8929f8762554e125f9b63a868a91938195ec6ac31d6702ee9b448b794a69ef2b2e911d4a546a9e9c6c526ed1b5b4da8612d2517981bba700ddf7f24e127d604056b946ed438fadd703728f5774fccc836e42d0863000a4a53c807aedd8bbf4783176834cf0d5ecaef74bc547e32b6e3702728d75e36a044022debe4b369644ec63529ca9c96e94d56d82448d2407ee2b5996cb5ab2108fa8afa21b79bd16211e0942dc54bab19ddae1a6857bb9b572a7bc8a3aa5b975d43e3707fb1a892b03a188beebd0867018e43a6b85ac9a59a57dd5e0da73fc1c70ed27ce7961e30788fa1e8e158faaace3d03dd3af8d58e82ecd4e87fcac2abe8c2a92964ae3e4fac25ddc5614a488dca3ece43ad703b987ab671ecb6bccab30b4605e46bde0ca3e3946c22ca31886f13cfd3f3e67f58dae459adce99c5fc06e0e00bf3e2b27567b99f74007858a61ae719a1c5e8248aa373ca159075639e9b3b5e48d3d732faa9e1068d3acb00a7aff085453894f8a90ca18a04a6862f282b26c04a1d9850d616d62e638320f99ff3f5e60dcf0997b846ad70b4aa6431f90ec55fc508bdbc3ab431b83e268658295b3323ceaace4f30452bd981ca41f6382e452b80ab371611f6e4b0be721670cdda069af87f647f62b41f9f274bd1e0c016b06101be9e412c76357af7afdb1611548b50ede8f74a7870e285980b78950a91c7efd616efed8665aa87dcfeba355c023b64f8e129f705e4165ad5de1d62cafe207bed9d4a2b28f6567db09d4c0df2785d99f827b041ccb37c8f90f9038951538d70ea011c0e52fdd3d578e0dc5a6976dafebb8c1f8d53de7d0d260fe02ae6a7a50fc4569fcb4bb7c156e8a351b360269dc8ce82e37755f7424d42e778aa90b98a6bf7429690bd421a897bfc9076eb3571ac1c95ea78d45a7965265a57b5f473e4a9fbb16f49fe7c4c6c584a5fd06ebf66b4cc3cd3eeb474991cc4eeef7dfda001264950ba7993eb27089416c800cd8df9e95f9d3b6ed4998d6b5cfdf8340d72133170a30f4d80079f697483a33c4d00da935d530755287dd6535bb14a875395fac26500ac1a01f4c6b16cf5d54b4a8cd3990136c44bbbd3e02e22db5f645027b21b561d1098e601f82e2ab842719a3dc4b102b85579f566261e7cb0d7d5e99aa807ae3018822297313252a8abcf7211c8194f9aa0cd812cc7add9e46acb822360b1fbb2882fd476b64e65d3f2e03ec4654b3eaad38fe553dd78ef34df3ab0691c6f97e1b795c71159bc9cb17034ee1f06bb730e1cd4e7b35152fee51b1abd10c41e5ea2cc2c7397f7ede340eb5a6439949c61c6e4b3e0ec2d205c190f9a5b75ba67e514b0e17230a7bd5a735926dafc876e54a6e64fb003ee0a67d746bc988e19dc0ccd89ac4ddcbf791f29220745443facdb376bff51d3a75dee07c0e4936c4b224df3aad65a9c9d9ce74907d741d055760c2134633a669fc2a6a5afa7c71d5c2308414f1eefb6965180adcc15a56146c57f626116d997f9984f6d419d698a19ec7b429f0606a5b30777149c3364593362b0facf1aeee412ae2e6df84385fcc1e9af7f9fe9999bf8bf494f4bc5225b8242063c9eecb7b555b841fa8c73c666d4aa127381fe1d3e11a0dfbf94470afc8cfcd242b8292d069d47df21aa9cc4470e6b6f62c8d66319f52dca2243be5e20fd135f0e3d19686f968de6e18c45fb5766e5565e611b0d4afe5b2d207711b80ae383039c3b831ca1bdc44520fd3c0af736ba1d65300db054a32c01a540c2d60dceafd1656ff7c464d03058f7a2feaadfa230a09a0d025e48547e96aed7c80f5cc02309141b552427382540f55a45c050231bc78ccb190ccf795ad1bbe4c032f9b4568dab2d92d8e0af3361ac1f38d2402c8fc9e4b854ccfaa293b8c72c2ab339793c799bd6758a06d5f2aca8582e5cbe64c960fd97a8e1244e68ec2473ed134992cacc568c179f676c8b8e58b92cb757f0519ec8daea9aff1a80422f4041ed286814fc3069a2844d573640dfe963c8006abd914dda4f103eb93f32345306ea3a66e2ab8b73dae8d6a2f810e6815ee7921e13f060ee2a07134f65f8d05d3c7808f10fc04b7b96158e385f9e9cc67a7b5fe238827b999817e8ee2b46e337004ef4322f19678dc27b371e8f64e228a69f49cfffbbf80deb7e47f8b27ce3c5b31bbf560f3ec301683b44d0845c5bf3b72bb3ac7252cf5a2e9233f0b1e5fc649a65a47046924b221852f524b70e212eaff8598a96e52b33799c9604b453a8ec5f34381789f754dc3516c24f4ba1a760ec31dfd6f0f3c3604995d17f3a924132a0b9df84d9bbcb0d8f1c6a0e694b8b050dac2f56629914d1f848b21a3a3e93ec8442f33ef8548fde599abc7017edd34b96f0ddff0b20e5a4802dd596b497e1187cd59435f690907e7b79144886b8e58f13b333711181c11d9d18b7389125c4b2c23977a16286e2fff2770002cbfa54f9587486bfc6edbdcfe20d2585cd2ecc8ad39922d30c5130e776966f9fddb197551698ecd9c123ba853c854b68ff4036abad9b49dd3df7fb46e47cb9ed9f739a4870c391782eb7afbe64b2ed6369d7a7baa109cb0594422a849d6c3360a6da726bd93f8564e40fc8f7ea2556431240efb4658dfd92038f7549facdfb3bce0f517431e3928942ec5b66b132cac1a6aca34a6d6993d3fd3f4279bc61d6ed9451627d901f951919548a28fdaa73dc4f28a93c95036643d2b29a31c61703de170d74ee950ee5a69f6ee92987fcb67945a8e483f94d3d9a5c941b3fa0e370786911f6692fa301c5a6b1f8c15fe8799ff229ed878f20c68deb72570d70b2208a9ac024732cf97b00774c2e6aa925a02d0a14ea241f02d3813e512bd5be8eda58f62dd19545c02df5897b6b971223b6186c852548d9b2be914f246af2ebcc432470cb34a2455743d761ab4449fa3ff9ff50b2c607bffcfce857421529827400e5026990ebc7f0ecef6fc12e534e1cf6d4e2ab38a9c92aa2f1809927c0dbd6383a3052e33fedec0e5a05bd84b60a8b6ad49e4f78e1dfb5b4c53f3e7b363b9a1fd84955e0953db376992cad5428ec4d05eb95cb7726b9469ed36268830d7ca3fadc3525054385a7d3cc9894d5495572f7bf2805e437eb7752907da1c37f6630a76b8998e0076d760807c3c1e316bd65eb69882485798d3d3d05c6d8b0e370a73c2e55f9016ca00d5ea582400d9a8e8bf41e3bea48c2dad329af87dc22ae01368380d157d1aee85ff3b722236986be4b3b1ae348bf0d741a4b83959e9ee9c000d467d364432f2729ec53d878940c9ac3301f829cc4cbce56b4edb81d1cdf3b4746b9cd2e246cb0350b3c9c583af202224562ff4727e2ac004b1ac505a612eb27ab752c0e5b2f0b9ec36ae23e065f6023adad1c1386b421b082f6f7d2b6fa7a469da347c25991bc4acbea0a7c9a370d277152fffaedbf519d64335eb822150dc1fc4e79b3c82e7f4078a47362cb4b9e7c45ad882644e905bf2cdf144dca31ec7a5ad5b90b618a965a8ff773435bc57ef4c2d91c094ae1b33e1e81a88eb920443874808dba7f2537207c23c38d85161a80ee97fd3496c8112fad8d1d37fa397ac6f287c7ad32d57c2e9fb56f16b2a0a6cdbbb03e9d80c80062d11a50c8e860cb6594455d368ff4736f9ced00bb52a1553f193af623e67a68b1cc79865cafed1b237f29392a0df0a6f6490da4d0cd6bf787e37e9a2147546a30fc6b040ae6d00374bc3e42c426af34503f5e24b4ab968065f5e13452dc3ec093bb41f5eb62b1596c665fd382718ab4e8d0ca2b67340f9a1fb484e6f07e5f7c9e752001544f05081fe06e5a3eede84adabf140085bdd0f134a77ef2e3145a87478de65003c838debff13cd82167f46f5789914d075826848064f1e6290e40cae822b37de37bd52b4f92e5197ddd808e618cd710c949c5687a68b7e89639f774bed0b81d341c83345333cbcb5c63a2ee87cd1acec32694fe225ce31fb0a208e87eff3f58d38ef504e9e88ee4a72f95f4ebc06dff23dfdb73192d9df4152267272c6908f56459c80224eb9ee733bb009acbe9350c0da9344cf879c6e0274829211267cc9d0ba53b31fae4cb97ccbd16a86df93c8f783195df7d17a6b551dbea45b789e5e1d1f2c9fa1a2ec04e07cd8e3db014689bd7da76a180430b8006622722d9f4130dcf6809b79ce2858f9fbff280f456bcba80ef4af77234f6a9a9e5f6629b52f238ca8edb98dfbe316025c15b46f1b3dafb899b6b8d4deecb26c19c7843cbe1b8ed6826a09e3cd2c847fe617bf91406c756d89cc84a045e8b30c3e5a3771c415f71970c6888fb9d191c17b7725db1e65084d8b5a09d122099c0f4530d89faacf1f99041348116994172903908514c5fa3d33f78ddaa80645e09c8383178780ae7e45f339bbe14bc38ac8737f1fb77ad40a0d892d5b7e607f061b06aa2f0ac0ef7a505ce7ec60cd0ca1c7524e1fd1cd3d01ab698787b71e61be84e974b80308376140d9f8464de0fd325d1b1317e5f02989be70c7d5bb1830c0d057d2f809ad5364aa683d16815ef91a7e71809e42ab4afc1ba8144afbe7037d3e6f142c0da6cb822db88129f818531c4674be5173415c308bb82c2e9c9cba97e72cac0e317d72f82f7b1562ab575bb001fe4df9d80106d573f2826f1bd42271849bf544fccc9ff8d81a40fd904a8ab5511a844ba5084bc1191e738d8caf06d4f9e2b895010052d093d4af6ea172145e73287abb98e453883f8fcd3e18872f3cc9ae09dc09baf08c13c3e390615c161733a6713997a1caba894ef9a54d10f4c079315db581bad6361adcea204dc03e345ec346d1443d478d9de757b53ff736a1df5732254294fbfb4e34e8edbdb9f4c9aff81941af9429b23bcf2d62a446d28e0c462abfb0799b56dbf5e152673bb8f379a319a9ae8857001faafd553a446f51880104d6ea5279d7162cc285610e194f9d70b0972a220e47ea32a70ce8a602ca2dcb6a1405dbdd6751f5cff043a1a00d1db8976aede3c99a1e00826499f7aa70ead8beef4416e7a71ac22d7c1bc1e4970d4166e8b4ac16def4356e573e18eb4d4fabbe5878d62bce92505023563a834a51609f82dfe62b54e0ae39de858bd6ed0396626ecedc589ec226da2824b2cc60a81a1ec2168daa708e885240dc45901217631746f9e1b4608e3005a8b558e40d152ee2b0323c0809b1092b3603cde0d8be5f246ea8dbb25ed6a1dc7b33549a29a852c85621ff5179ddbbd73efbe1ea0f59a02c0c97fd4fb00a3b2caf3e3cad59d80369eaece4e360e91b0f1ec97491e383927239b19a19a6484ae6415409050e5e45500821c98eb748f1d5bc0f4e8a374b739e49df997d472e023fcafa90ae5d979d08ea0e9d4439fa0e196b9ff882a0ae06446410e26720a3e5a2c9564c9ff5660ea0fffe952f9bba47056ca18c9b2cfb42564c3b7125de376d6e4c8db159615fc8cfffa85de97c7e3356a062e90c9ab362a4e865bf16bc9a9248aba47d0c2dc39ddf89904626598bc066556db45fdf1c2b311ce6c6a1893659bee718198fd35e3092fdc94968d7186828fb0d466d4e2d6c9bbc2693f96d7f2f97d49638b77ba5af45a8738fdacc1c6b54c098709ca68b7543f1896d4b72b41b251cd22dc01d12d29c7c2824192b60851ef31a69a8830f2231b8a15869d8b0e87bf6a0e767df9511cc959e2e09781d1763090cdc95dfadb9d48152a82486d35eb82f2044d88ec95f5d633b18a12762c1448fbf25c64d4bb1a188d0d814147dda0655d2955379d6d328adf5808c9e530ac79d87d73778c69ddab5120d55c31a0b354fbb070ee1a8d243572f7177fe8e4ec03e2a8302a8419f59fb90b4f3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
            <tag> 域名解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础语法（二）输出</title>
      <link href="/pybasic2.html"/>
      <url>/pybasic2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="目标">目标</h1><ul class="lvl-0"><li class="lvl-2">格式化输出<ul class="lvl-2"><li class="lvl-4">格式化符号</li><li class="lvl-4">f-字符串</li></ul></li><li class="lvl-2">print的结束符</li></ul><h1 id="输出">输出</h1><p>作用：程序输出内容给用户</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello Python&#x27;</span>)</span><br><span class="line"></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求：输出“今年我的年龄是18岁”</span></span><br></pre></td></tr></table></figure><h2 id="格式化输出">格式化输出</h2><p>所谓的格式化输出即按照一定的格式输出内容。</p><h3 id="格式化符号">格式化符号</h3><table><thead><tr><th style="text-align:center">格式符号</th><th style="text-align:center">转换</th></tr></thead><tbody><tr><td style="text-align:center"><mark>%s</mark></td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center"><mark>%d</mark></td><td style="text-align:center">有符号的十进制整数（包含正负）</td></tr><tr><td style="text-align:center"><mark>%f</mark></td><td style="text-align:center">浮点数</td></tr><tr><td style="text-align:center">%c</td><td style="text-align:center">字符</td></tr><tr><td style="text-align:center">%u</td><td style="text-align:center">无符号十进制整数</td></tr><tr><td style="text-align:center">%o</td><td style="text-align:center">八进制整数</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">十六进制整数（小写ox）</td></tr><tr><td style="text-align:center">%X</td><td style="text-align:center">十六进制整数（大写OX）</td></tr><tr><td style="text-align:center">%e</td><td style="text-align:center">科学计数法（小写’e’）</td></tr><tr><td style="text-align:center">%E</td><td style="text-align:center">科学计数法（大写’E’）</td></tr><tr><td style="text-align:center">%g</td><td style="text-align:center">%f和%e的简写</td></tr><tr><td style="text-align:center">%G</td><td style="text-align:center">%f和%E的简写</td></tr></tbody></table><blockquote><p><strong>技巧</strong></p><ul class="lvl-1"><li class="lvl-2">%06d，表示输出的整数显示位数，不足以0补全，超出当前位数则原样输出。<ul class="lvl-3"><li class="lvl-4">示例：表示显示数据的小数点前的前6位，不足补0</li></ul></li><li class="lvl-2">%.2f，表示小数点后需要显示的小数位数。<ul class="lvl-3"><li class="lvl-4">示例：表示显示数据的小数点后的前2位</li></ul></li></ul></blockquote><h3 id="格式化符号的运用">格式化符号的运用</h3><p><strong>注意</strong>：在print中如何引用变量，<mark><code>% 变量名</code></mark></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">23</span></span><br><span class="line">name = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">weight = <span class="number">75.6</span></span><br><span class="line">stu_id = <span class="number">90</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.今年年龄是多少岁 -整数 %d</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;今年年龄是%d岁&#x27;</span> % age)</span><br><span class="line"><span class="comment"># 2.名字是 -字符串 %s</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;名字是%s&#x27;</span> % name)</span><br><span class="line"><span class="comment"># 3.体重是 -浮点数 %f</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;体重是%0.1f&#x27;</span> % weight)</span><br><span class="line"><span class="comment"># 4 学号 - 整数 %d</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;学号是%d&#x27;</span> % stu_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.名字是x,今年x岁</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;名字%s,今年%02d岁&#x27;</span> % (name, age))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;名字%s,明年%02d岁&#x27;</span> % (name, age+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6 名字是x,今年x岁，体重x公斤，学号是x</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;名字%s,今年%d岁，体重%.2f公斤,学号是%06d&#x27;</span> % (name, age, weight, stu_id))</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>今年年龄是23岁名字是tom<br>体重是75.6<br>学号是90<br>名字tom,今年23岁名字tom,明年24岁名字tom,今年23岁，体重75.60公斤,学号是000090</p></blockquote><p>格式化字符串除了%s，还可以写为==<code>f'&#123;表达式&#125;'</code>==</p><blockquote><p>f-格式化字符串是Python3.6中新增的格式化方法，该方法更简单易读。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拓展</span></span><br><span class="line">age = <span class="number">23</span></span><br><span class="line">name = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">weight = <span class="number">75.6</span></span><br><span class="line">stu_id = <span class="number">90</span></span><br><span class="line"><span class="comment"># 7 名字是x,今年x岁，体重x公斤，学号是x</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;名字<span class="subst">&#123;name&#125;</span>,明年<span class="subst">&#123;age+<span class="number">1</span>&#125;</span>岁，体重<span class="subst">&#123;weight&#125;</span>公斤,学号是<span class="subst">&#123;stu_id&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></blockquote><h3 id="转义字符">转义字符</h3><ul class="lvl-0"><li class="lvl-2"><p><code>\n</code>：换行。</p></li><li class="lvl-2"><p><code>\t</code>：制表符，一个tab键（2个空格）的距离。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;hello\nworld&quot;) #在两个需要换行的字符中间加入\n即可</span><br><span class="line">print(&#x27;\tabcd&#x27;) ##在需要字符前空出2个空格加入\t即可</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@Python/pythonStudy_img/image-20230509204225546.png" alt="image-20230509204225546"></p><h3 id="结束符">结束符</h3><blockquote><p>想一想，为什么两个print会换行输出？</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;输出的内容&#x27;</span>, end=<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>在Python中，<mark>print()， 默认自带<code>end=&quot;\n&quot;</code>这个换行结束符</mark>，所以导致每两个<code>print</code>直接会换行展示，<b><font color=red>用户可以按需求更改结束符。</font></b></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>, end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;python&quot;</span>, end=<span class="string">&quot;````````&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;wer&quot;</span>)</span><br></pre></td></tr></table></figure><p>此时第二行代码与第三行代码中间会空出一个制表符距离，而不会出现默认换行情况。</p><p>此时第三行代码与第四行代码中间会出现````````，而不会出现默认换行情况。</p></blockquote><h2 id="总结">总结</h2><ul class="lvl-0"><li class="lvl-2"><p>格式化符号</p><ul class="lvl-2"><li class="lvl-4">%s：格式化输出字符串</li><li class="lvl-4">%d：格式化输出整数</li><li class="lvl-4">%f：格式化输出浮点数</li></ul></li><li class="lvl-2"><p>f-字符串</p><ul class="lvl-2"><li class="lvl-4">f’{表达式}’</li></ul></li><li class="lvl-2"><p>转义字符</p><ul class="lvl-2"><li class="lvl-4">\n：换行</li><li class="lvl-4">\t：制表符</li></ul></li><li class="lvl-2"><p>print结束符</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;内容&#x27;</span>, end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础语法（一）变量与数据类型</title>
      <link href="/pybasic1.html"/>
      <url>/pybasic1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="目标">目标</h1><ul class="lvl-0"><li class="lvl-2">变量的作用</li><li class="lvl-2">定义变量</li><li class="lvl-2">认识数据类型</li></ul><h2 id="变量的作用">变量的作用</h2><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@Python/pythonStudy_img/image-20230503114212314.png" alt="image-20230503114212314" style="zoom:60%;aligin:ceter;" /><p>举例体验：我们去图书馆读书，怎么样快速找到自己想要的书籍呢？是不是管理员提前将书放到固定位置，并把这个位置进行了编号，我们只需要在图书馆中按照这个编号查找指定的位置就能找到想要的书籍。</p><p>这个编号其实就是把书籍存放的书架位置起了一个名字，方便后期查找和使用。</p><p>程序中，数据都是临时存储在内存中，为了更快速的查找或使用这个数据，通常我们把这个数据在内存中存储之后定义一个名称，这个名称就是变量。</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@Python/pythonStudy_img/image-20190122123202213.png" alt="image-20190122123202213"></p><blockquote><p>变量就是<strong>一个存储数据的的时候当前数据所在的内存地址的名字</strong>而已。</p></blockquote><h3 id="定义变量">定义变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量名 = 值(数据)</span><br></pre></td></tr></table></figure><blockquote><p>变量名自定义，要满足<mark>标识符</mark>命名规则。</p></blockquote><h3 id="标识符">标识符</h3><p><strong>标识符命名规则</strong>是Python中定义各种名字的时候的统一规范，具体如下：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>由数字、字母、下划线组成</strong></p></li><li class="lvl-2"><p>不能数字开头，可以放在中间</p></li><li class="lvl-2"><p>不能使用内置关键字（python已经定义的关键字）</p></li><li class="lvl-2"><p>严格区分大小写</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">False     None    True   and      as       assert   break     class  </span><br><span class="line">continue  def     del    elif     else     except   finally   for</span><br><span class="line">from      global  if     import   in       is       lambda    nonlocal</span><br><span class="line">not       or      pass   raise    return   try      while     with  </span><br><span class="line">yield</span><br></pre></td></tr></table></figure><h3 id="变量名的命名">变量名的命名</h3><ul class="lvl-0"><li class="lvl-2"><p>见名知义。</p></li><li class="lvl-2"><p>大驼峰：即每个单词首字母都大写，例如：<code>MyName</code>。</p></li><li class="lvl-2"><p>小驼峰：第二个（含）以后的单词首字母大写，例如：<code>myName</code>。</p></li><li class="lvl-2"><p>下划线(推荐）：例如：<code>my_name</code>。</p></li></ul><h3 id="使用变量">使用变量</h3><p>定义变量时，需**<font color=red>使用单引号’ ',引号里放具体数据</font>**</p><p><mark>变量需要先定义再使用</mark></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_name = <span class="string">&#x27;TOM&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(my_name)</span><br><span class="line"></span><br><span class="line">schoolName = <span class="string">&#x27;黑马程序员&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(schoolName)</span><br></pre></td></tr></table></figure><h3 id="认识bug">认识bug</h3><p>所谓bug，就是程序中的错误。如果程序有错误，需要程序员排查问题，纠正错误。</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@Python/pythonStudy_img/image-20190115125845015-7528325.png" alt="image-20190115125845015"></p><h3 id="Debug工具">Debug工具</h3><p>Debug工具是PyCharm IDE中集成的用来调试程序的工具，在这里程序员可以查看程序的执行细节和流程或者调解bug。</p><p>Debug工具使用步骤：</p><ol><li class="lvl-3"><p>打断点</p></li><li class="lvl-3"><p>Debug调试</p></li></ol><h4 id="打断点">打断点</h4><ul class="lvl-0"><li class="lvl-2"><p>断点位置</p></li></ul><p>目标要调试的代码块的第一行代码即可，即一个断点即可。</p><ul class="lvl-0"><li class="lvl-2"><p>打断点的方法</p></li></ul><p><strong>单击</strong>目标代码的<strong>行号右侧空白位置。</strong></p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@Python/pythonStudy_img/image-20190115130541289-7528741.png" alt="image-20190115130541289"></p><h3 id="Debug（调试）">Debug（调试）</h3><p>打成功断点后，在文件内部任意位置 — <strong>右键 – Debug（调试）‘文件名’ — 即可调出Debug（调试）工具面板 – 单击Step Over/F8</strong>，即可按步执行代码。</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@Python/pythonStudy_img/image-20190115130809100-7528889.png" alt="image-20190115130809100"></p><h4 id="Debug输出面板分类">Debug输出面板分类</h4><ul class="lvl-0"><li class="lvl-2"><p>Debugger</p><ul class="lvl-2"><li class="lvl-4">显示变量和变量的细节</li></ul></li><li class="lvl-2"><p>Console</p><ul class="lvl-2"><li class="lvl-4">输出内容</li></ul></li></ul><h2 id="认识数据类型">认识数据类型</h2><p><strong>在 Python 里为了应对不同的业务需求，也把数据分为不同的类型。</strong></p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@Python/pythonStudy_img/image-20190111124628584-7181988.png" alt="image-20190111124628584"></p><blockquote><p>检测数据类型的方法：<code>type()</code></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))  <span class="comment"># &lt;class &#x27;int&#x27;&gt; -- 整型</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1.1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))  <span class="comment"># &lt;class &#x27;float&#x27;&gt; -- 浮点型</span></span><br><span class="line"></span><br><span class="line">c = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c))  <span class="comment"># &lt;class &#x27;bool&#x27;&gt; -- 布尔型</span></span><br><span class="line"></span><br><span class="line">d = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(d))  <span class="comment"># &lt;class &#x27;str&#x27;&gt; -- 字符串</span></span><br><span class="line"></span><br><span class="line">e = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(e))  <span class="comment"># &lt;class &#x27;list&#x27;&gt; -- 列表</span></span><br><span class="line"></span><br><span class="line">f = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f))  <span class="comment"># &lt;class &#x27;tuple&#x27;&gt; -- 元组</span></span><br><span class="line"></span><br><span class="line">h = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(h))  <span class="comment"># &lt;class &#x27;set&#x27;&gt; -- 集合</span></span><br><span class="line"></span><br><span class="line">g = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;TOM&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(g))  <span class="comment"># &lt;class &#x27;dict&#x27;&gt; -- 字典--键值对</span></span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ul class="lvl-0"><li class="lvl-2"><p>定义变量的语法</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量名 = 值</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>标识符</p><ul class="lvl-2"><li class="lvl-4">由数字、字母、下划线组成</li><li class="lvl-4">不能数字开头</li><li class="lvl-4">不能使用内置关键字</li><li class="lvl-4">严格区分大小写</li></ul></li><li class="lvl-2"><p>数据类型</p><ul class="lvl-2"><li class="lvl-4">整型：int</li><li class="lvl-4">浮点型：float</li><li class="lvl-4">字符串：str</li><li class="lvl-4">布尔型：bool</li><li class="lvl-4">元组：tuple</li><li class="lvl-4">集合：set</li><li class="lvl-4">字典：dic</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conda常用操作及源的配置、pip源的配置</title>
      <link href="/techdoc1.html"/>
      <url>/techdoc1.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3ef958c5979a8d90dae57e126642966f57d0da68a3fb109159e846e6e1cfff7e">99b31b6368a5aaab8697df1cede80057ed72ced6d35b24de9e79643f0ca7c723ea2d21809e968cb9c3badb39b867b0b7f2ecd54c243e22ecc5cfd3e2c85eade64572bf26d0c0dc1832e2331c2e0c24bc456598f4d70d6036ac1a95ed027bcdd833c01a35f93daa2c7b98e42228a589ccb68d3f4290d7faad643c9efa56534dcbf38c700aa3fed80ce8a95d9e3b8e277ce941d6615648e580ab5947ddc0b72f7b2e7a3bf083a3b4f70dc7c4bb803aac854ab70afd6b611b01faebc3195d38d0ec2df39ac8078501045a6126e22a05f88cf4bd67fd12cecaecfdbb9e4e43ac7a97320c0697caf5722045ad9bc4da0f4a64030ccb7ebbda50b45d89ae2a8812c92e685933f9ce697198581f2d1a12a3f2c56a096d65ecf1da0778b7b5faf19c3f9a9f8da25ddccd8ac8f4cdbd49fb839944a088b1ff1c798a3f3b884d13dd3d20aa5dc358fb1e16296c8f5a8800a12716b477c8968742a834422f73946f31f89c7329ab4724cd7ec0882a5dcb7b9a711e4b317c79f5f0e4f48a0e471001499aa6451acd6540da8760b13ae49ae43966c3bc355ec2bf30f89fbb3c28ca47f7855f22cd7f38248c4e2a05c6498e8a796cbea64c5d851e703af1c7797be428ad2413b145a8293f92328f58187e6bebdfe0d23cf5f0da634301a7fe3333cc5a4100478ce6ddd2f7cb06c7acd2db4bc721041b2eb9c332eb362870e1b70996ffa6f3b48dfefc6883de92297134dda50afbd77830d8d2880866655dae6b3438bc7d0824eaf51015067fc4e0a2e91d7bf997c9333a174c5f538d901a2513c3fe411a7e078377bdd4995a262fa3bc05b86c3367fc3abb09098e25cba7a715dcdc30b9693934ae5c132c073c677a73c88211cab4ac704fe269b41a6fee57a52a40b2f9a9cc24db315190ca79434211e263ecc7bd1f7a7442ed8bd54c930d4be46a06125bc024a020b0a2b2cb6cda470a233b7b742d3c1a18ad7e2f762ecc560067d57bb88d02435093602bd165721884d7d05b104cbb8f4c41879835261bfd73ab5879f0e26b0f43e4778f7b4c5ffec6322c2806401208bc1e88609ba3bdbad765cc36bf7edb0e411a57f26106cd084d9562b656eece4c08562fe37ace2b8ca0ed3175023d541c013842f8b7aa77171771eacb1a441beb821594a368f1bfd39afda502c3116a3ee0b3e7cb888ba6e636c0e6622ed1860b84c6f6712c13d8ba533095513090b1c30602ddabefc450734cfc657cdd8320d777ff697cddd53567a0420a6c96049b15c000d1c60413335745984cf4a1797b58d7dfcc1f471866d7dd69f34a06b186abae8ea4f0eb9fe516955a9107b73fa271f7ca5040caa640521d0fe4c77710dc95e7cf2e1878ac13c93d348d32323dd6fa2561e045bde85090a7d2684d157332e2b39dd78c12497e0b6d5d952e0532464170a7834d37355417314ebea30346f2cfc0ebffc8ced6e953cdc17a9ff610a0f6b9150b4b319621794a9fe11f17dcb2be7acbde612c6da4abeacfffb2e0fbd7762b44e3c527c257bd4d8a7792d56b7aed4faf40be2eca4b9f16d21b4ccdbeea61512368c16ea720561d8e319d7876b7ba00507c91e5fdc0658d03fdbb57db2b62a2aa36881fbf3b6c710afc6724148762f13d343eaebf3fd1d01e0b5bd647f9a13a4c0c2f2b3e425fafc53298a6edbe179ac6edcad5cac677ec5be745eaa79391fa3f5e4e2b73b444abd2f115532a6716ecc340f96fed4837f5c13e9734bc5aeaf1fde9fdf419ad30f0c68b3a4fbda4756cb566f9edfaf44c69f85563ad9388efcc45d55f4bbf127661aa98618abe6a4c5f199b1250c382a8625bf950df5cb1b89d0d3339968fd9f5c0b7e528513cfaf4ccbff9aac9de129c2e69038e604bd511cbfe315fa8e23f0ec56dd258ac6da49967c3166d54ed0fcbe8112848fcd4adf30c60849d964645f6d28eda42a997a9955160d5d02087dba36865f49a42bf15a4cf302f84ec1b53276b2b3a028343404a30e5c9fb9877839e2ed41a5ebc023281b4a3661c2500dfef60e5564a3c301cfaec843f8f98f9c01494162dbe72f93fda0a60751fda1e0bd1579833963e9ebcf69643faf1eb92763d317db60b5c950b6273dc092cadb7d04fe874a0b91752eb1fb563912b2a02b6c33f75c93e6f27c357c660053f808eab6ed8e9231ab04b11016b79538194f771d6cac5db4203406a697bbf61640c04a87cf21fb866c16489f80c49ee3a3693c6b07c4bc80e8d62d8eadf883a4e85ac647c690c65dd67f8fbfbdcdebbfe3bdfa3cd89b4554210357b239b6b7d7a755f4c9258a161c31fc67ee3b0c3a4540686f471263b91e3dfa58c385768681f242c38aceedc5dca390e8c9391607d1114649ca48e91f3d3e4cb035b37b173ca216b51590a08710b6f315d61ce658537e32e75e7a5699d28e2cc2cd4de8e45298f073dd75ba5f9f4e7f87a7bbdf47245773c14ff2ea5276910a614992312ec03b71a906c1397152f972822c4d6d0a70dd0d5d32c20e260b3f03bff988208df833ac95ef398a59a1b78b06b7a44b99421376604375ebb9c857fc2aa3d4766e3d035c4ff2f96033a48ca0b2df82124b025e69aa8cc0b537ddf00c8fa3712d9cad7f803aacf56fdead319278d73e5321175f13787e6aebb51aca1a62625b61484804b3864f0daf66eb38165e2d26686138da71158dcf16781a2ec9ca86d8817578234eb39d256a57ff8168eb1bee906e64c40e4dd0ff0fdf105f9ab9b74a7b5a2beb113f3b36cda8bdf1adf3a3158e14bf59be5fc6ba0698cc1983a7e9523b5e430e5dad39c5f753b4e6f4dcf4e6c681051f8e173024f3a6ce4ad9e3cb252f4a4f437c9eb48742c9afc047af263b433ce9c12545faae18626cb13cdbd22329676df578fd2b8951f36fefb072c55adf800edb670df6926216fde77881649c4e73a61c1c8d0908adb4370077de0217815fb8e065bf2ea5521eadfffa87b5c459df6533d78956805995c4f934ca693b480c0508ac6a0b7fa3e1651be1c24fb6211f7a4e781d28e1791c6d4108dc28a1a448b567cf3a90ef689834422ebdeea2b52d00e3aff7c35e8b399891e98f4294c59c1337a4278fc5f025ef6225bebe6ca835831ba49ffc0d2388e7e96338ab55c0a505c9977a10f334761b6c6112e3590aa20cc37b66849213edac07ccb55b0df3502118810db069e0b707c05cac1ff7c949b73ba3427c297f5160c5a9af1607d8fdd97ef67e743b70dd279d4151cf84b2f80e76807fe1b768bcd24da666124d6e57bd10c332718ed5326f451b492031d3bd47aa6d128143ecb3f5157fd45cb801b3c1831707773da95aed2aaf62229031df5ade75a89208595a240f6ef01512524b6a30582d7777eccc18cab21e5de06c688b60c746340573ff0180296e9b38f27b3de6c0cadff12ce8803d55f7f7470e059b4ca95c43765db95a6a6b6660577ba63557d1a32422525da7c96ca431f13a0d6fc557005d0b07cc9c6549ed371ef55c9ab12c48199150e1aa28091511ab73f654fa8123e78d6482e1d75e084a02d5bc492c762d7f9d3cbe4e84a3770c709d2c9267a88096a04b68150e27edbd75f594717a70b0bfe7e7641920ab64efa02f5bda6d0f4774f0fbe526425331c052b2358690f99dc2c20fabb2a2218eed8b902200b7dd0dc6a35e1f21945f26dbf3d47f1f20b200ff1f1e251da0e58b1ce7f1a865c401d23e42c26f6656b79194bdeed2130697757cdd46abe95321606c01168ce98afeaac1cd2b60ff2513cd65a6eea399ad2ea80e643fdae03c7e71309d9b2fa30180cd6296bbeb2512cdcea40c816f61aca8f031e110ea802aff6271ed1acd772754b102dee7038ec6ba4945ebc8c016aaf333afd9eddecb570f6fc4c9a9da16560caccc4d9588fe12ed74057c4073ec335648afad096ee12d8de812d43cb92963db6ac14018102fe4c1120ecec926f6b566c6d33afee4bbdc56418c54430128421f05b99c336af2e44ece92b4eab6b6f3eae5806df189feef8d635cd474417d05f5a9bbd99f813b2ac1b10c35f6f17664087c158ca83e492ca4bcc6732c91f76376c6c7a856f3b501480063d3d20c8083c293231e96f127dce7e73c95930ca8ad884b70b68d663b679830ba3016afd9512f1a819c14c7372a5225fa853585311150f2a6f86e3780466650161486467d972941a99bf704ca6bc1230edfb749b15db12a82beb9cba9bcf771ae9b028ae2391742d99190da19cfe0641db97e0309abdeaece3fb30dab9ce7c4a02d2a420811b019c0694d378d481f6dc43bee6a4a7123ffcb7c5dd5cd2929d4d6c600ee8aaad088669c6ed95244d394fc4ca4397c6800c3b9c2f87942ee78262d996be30546099617a09d34fd39c7b6e1ef0fa31074ad4c8e4e5a508257bc1964ce67b8eee3a5d1576d3c6bbb94b1b63cc787b49a012ed9f685feb06675bf55ae47367fa63273b8b3aae72e08aee3a3aa79228497817c1a3049256338a3bc63d2bd2c6adea4cdeacf1a4162ac7b44a000a2f3e53a98948ba6b5a327eba7f2007d0d1ddc3d3578882d824157f74b1555620d100a695a250afbebc1debcc0a458b221d7d5451a3bcd7ccb67a55722b1094e06b5bf4b28889c264326c6aa1b253881a5493a8bd118c58701125138ff6d6a3f69cb656e89e404df7284d70b42b16dfd8712605babfe353bdd1ca359654542cf4e18836129901fba9d5a6b09771aade66d45d2e2a2c02bbc375891822a532d2d9702b2066708c25e79256b9d8291890b6a2d7da960cf017d22f7c6e70fc4a16fd23c52094bdbc4dc25c7fa012d5de5594d295ab13beed54e7aec0d6f14476de1bf0adc52f380ca052f111599eb3595d2f23342a283595ff3c2443c54c388a36f76f55fa9a1142c81ae45fc3f8796324e40f8dfb2498e32778f6d27dad55519ade650242ec60f4c5844ca51c5d14f6c2356220b56919e9341569f6aa46eec04ff7a0409d24be716c1281599503f3a4edd062f378fc40d907916b2ce44a4fad29165dd32641aa7f5b36cddba879f5bed13309e85f08e2e2b085095ac611901d0ea527eddef1021b0201794e9661789c12db39e31dcb2f3580bfb587a8271e2e99a04942048d3e86e836d62969f47b62956181287478879e40502df219048bf47cd6935746be62c1770849a730a74c98ece6f533a49a95626ce16b01bd520aca51c3255f76792ab36dac6d48537317e214c1a05ebc2b8910cbb3042fddc8c212037dfd25b060eb3a975826b9bee52d4f95d54fd598192ab892eb4f6b9910e0ccd124cea1904e1dc00887ef25116105d2273a3e35716c863ec0156cd926ada8dae7653be5ea1358a83917cd010c30555f6d0c340fe0f167636eace0f4046fb262af41e06bdeb6a873840e1e622df6b5865cebbc78e6e35c3a0e3fd61e2b047b03be90aa3bfaee88fb4e4dd0d26abde8c7e699312a31df3890c3fbd36cf7137d193021aec5a40f4da710bd16e960df3bf85fb0564a2606347a62b94bb0cc13bb9b0eb560951de38f094bc3c32cf25f2be688170dbed68c6edf6534c71c0a503a91631dc8a62e1674cd12c80808d466c924888f5ee206c0a72580dd9b73fbe18516e03bd8de2195edc40b9cd3ae4e16874f344ef2ea55261d7f05eadbc25da81a4d94675b73e7c54ce24126e8a41a714e297ddc45d91238f6900917ef668dc39700f423dddeaebd36a9984e8a5229697131c3249b33b88349a73581c9dd5df074d430f783e91606c62e02a077832420cc1cfdafc0c23da6e53504029669d43f61bafa4514fac50ab1355745e9e52ea54caaba6d70b61be6202e21817b8ef47884685072844683cd0060a4ba699f4a923b590faa5eb1ad6ea6ff479644c98c241c2e1f410dd2f4e2c5117e4f8bf115b702b4e55b77ca91bfb2f6c5447e51d6d22f60d941cfc7faa76e74c3281ce38e5f7879c8cd82860b2d45603cefdd23b747b7c02403110765c4ca33d4531ad5f5cc4e291c02b6ab3f4766d6d7037bb119477ee0913104c69cc61966c18aaafe9d5bec1da3c62825475a73aa2f09a325b19913da7a06dd8f49fda725623d58047ca8174ad0332d13162757687c82bca9c79ae6b052f040d75880129067f1a62622f051f8cdaedbcc879b17894eed433d8d2eaedf2e5b9b6985e7aff4aa7a7b9c90237e16680ec9ac66daa4b95b48cb41e35083c96685de9a2a1c21ada0960e2abf89b5ad305adb9d5e057d6704c345fde10f672848748802f27d2c8701ba99f9319dbd224b2d00888019141553c414a92430ad88f373b8404b66cbc477dfdb9058b5be7378725cd5de2619e88d385c4ea1e8dadc164c108be76506f3c1b4c8e1fa99b8c016b031328b158b742edfbea7b4b8607156a4bc7545b0a45f27d5568021e068cd7e2196a9f285f318851c00fe90a93fd10ee4678f51a3874950d4dc27cb5a6acbcbe17d9d16be6794c1c1a58f8bc5d7d9c53b837d642040c82c6107e6051c7a1710a60a91d0b5144a68a8cf7a488d4a6c56c6e784cd71ac69ddef1ada31dc4c7e2d1d49053dda825a5a91975cbe1d2e2480c348beb85c89ee4baa91d4228510cebbfda0b79be3794b95c8c09b283403a0900f8fc4eeacc32546e60c142f751a162bdb0dccb47877d186f35b7dbd6c6156d625edcacc598cdcaa7b052fb0015b257ef970213b6d6b0a9ad21b05e8cafe807ccc083b1e17867af3e4b70a093575fc8b0fa95dcf011f46f140c5cf0e51e55c967fe4662413f448b888b9303a94b8c82c002b2960ef115bba6313510720ce8038ce2c18abe6db66a68bafba9a8b68a9fd3cb29679b4d7458202f091f011d08040984e206249d9b29d0d963709f01d168f2dc5d68f6b26db315fc69d9f77a2747e3ce0835725498da62440b1bf4f92adc04edd908d017d53b011758b01901589cb8f14c9ddde5999f98dc45caf93f15146e3b55a61e444c987e582d1c1e6e74d8a219ec714300125fff97997646f3d52f49bf3bc6aba7d5cf16397809e1699c7dbfd90de5536bab1b8c40d2c89d71877221300e5f78ca5aa030ecd3731833a62d7eb5cf88d4bc898d28120a62e907fb75aa0511898a5677318676cdb34df8e378316c7bc978aed3543a9b92278b40ffc831b71003d6961646b9be0111c3e963cbfdcc0e4b3bedabf79fbe686870eb57a84f5db5a363571350144795c986d898fafd5332528a7a736c602908f8d810716acd27044a38accea60a10326dfcff8ec922d800b8747b8e8cb190ddcb492742e4851cfbf79e77b8cfd4d1f66720d1055eb46a450895423f479349a83f324ff97d2fb98879acb911693146ca241ac64eaeb3da3052c7317cfce6af2a89074c966ab1ec1ed422f1c039e98891e4d992786389278606f1e05072e9952f14230ce9b8a2005c789bb61e79ebcaf57169e7a1d50a0eafb50fcb36ecdc9c9208195de012513b0e5abba4eb7a60764d8d24c3b4dbe48377f2e5e4a824bd1935cf921c36fe6d54899397c7d7b666613082dd7057ab1054947eb08a5fe67069ab8474bc2854bd98fe94b1460fea659ea9ca92c46bdd61a62e1ed64f065b6de3bf41a71ba8cd3e420cf392a591b39288462004cd426eb8d7aabfe6845cca336347a2dbb03c4c4bc1baf4ded3b4cdf90d279130880241aa75a431f300d1801d312a1487d7446f270a6280f9f45db06ea76a47debae1643ba3263b75971752ea58f2b9e35c186065a458cb97dcac00e11ca971566f08bd8f1d5add91631715d4533155b32ad2b270b43faf82ed8552394fed3bc994ffd92b7184a8db36d758c7eaf642bbab45e0c068c40feee29e0c56b59b8d9352069cfa7aab4a38270eae7b86575b781f6721240a131d822415790db056b619c5865e64e73f369daa682467aab099fc5ce758135f451f602127cdaae74d647348ce660c388116deb2888782efe2a9c634f22935277170c233324e7d6dd4a4d147397a590a437cc7059d29fd7629f624dfd461d77613d32fdb7423bd8b63385ad920bdaf26ddff60e160adcba50ce4120961909abb4318d1bd82743c8ca6219d8f286708bf934304f129490667979346f31a775664c809c4c3f882969287e9dd9d8e3d0531a4e9d5d4f1732fae5ac99c1d72dd2f93832033d8765642133d8f5b312722e3e8f2e4b070d21d1b15fee9da69e3ccbb8d8fe167659dcd8ae645822614115c142db0f8df6d7efdad249c6382c1b1a49891f33d1aee9fc33320a086615c844508ae1a64cff7050d5895d1c3a487d0ee852c42ee1011ebbfb1b08ec47bd2bd29f36c768552b58d82f83afcd910ee4b0613717da380fef8d4b2c002b4e23da86f39feb35d0b598086b0582951f7db4dd2f30f1c3c7b1db24f8df879bbb5cf2f41778ae0501b41df8da29c1dd4f77054cd9b86a3d559281225441456ec5e650acfcdece1ffc1b64ea7e84567003b5f7a8f1f447f8cbfe26240499f1495be9ccd8438dbe57da9e02941be7b590204fe4b79c8ef613f535530d81515b5668588bc3ec5b016750f7bb618dc0cf09fd78bc29f532413b351e68b46f2fe62fd07d9b579b57325c01922d8a17fc8eb826775dfc8ef214a9058604c6a2d1f2186133edf0cb917c07273726eb75a741bd68190fd7cfcb23400c9dd35cd332e71150259685eedc4605cf825c1eaa3f711d220b4d3f63868bc8e156cd62c8d7e06cfdbb953c65df7025c5cbb7807b348106f219628c1461b085f09283af6d1dfa5835cb6ccc29156b37299249fcd13d299e8a3b3708775381953f908f88f1dc159efbca1265b15a37462fef5e42b64d3ff4cdc80435308c6cc9d3eb92d36889fb86fc0c193e76be837d2ea1038f73e5e619759c3017742e3b54ac7d09983ce0cb25ad6badc50035b10abf9f5fed0d2262f7370c5bdce229eda5440201918b990c89bd887c9ddd198899be4008e9c173635a33fea02d5c932c05f2638a80bee94f6e8b94c06bc2ff30ce77440ff9903ad883d7e930da68763d6b8bd46d7ca4af108358bcad1c1e66397e24579b73be4a424284a0efa107307bf57da376d0734b62f6557e645475ab5da5fa990ddda75e08b1bd9a2bd2a24732cc7b35538c36d28928aa1c2a09f69b7dca329cacbace8776a785148ceaa4e25c30646e7f27fa99bc6247a9e58ef30475cd53cbba73ecc14f1d0cb5c70d73284ff296544947c45baefd28dd97a63cdc0ff18826ff438faca9b790b036805e2182b867dd990f7a78639ad48e5324d0cb37aae6f0b39169cf005b9942d76db10492636f0c023eed5c622ec8f9a9c61b6cf179548a75905d087edbdb0f3aebc772fb70fc7792c4b509492f3ef555da2e2f5f8c10b86f936fadf1f53337671888c06c00d5e76a25220da832bd563a51c3e6d2debd82f76c410ca478bf45373f08090b9c0296c36dc665687eb259d84ab5e68fba53b1b2e6c49d5902d3eb14e43b4fd18f1fc2178743e1addefe6c08320880c43c09582b2cae7f373c107d3c0abfe21ea2682244868adfd908a189bccd27771ad4a05cffba51140b71854dd38865b8060f3066fa4746d9a63d79444ef510e80061f737e99704f48bca74124401de1163d0af0a82f01e034e7b32c620e255512893d731cf1bad092e113adcd2690d7117d59fd23168af90b9091f354668ea10663fe43ed315e31031ae9e158f5bc695e007be3a3e7d6f2fb0122f8a65df63fb705b065cb6c7bff5d74c5373f8fa0f8cbb82802e75d14db26c171c43e74cc7b600cc3d0adef1e6515910a1ce5e7916513b9cb7be0831150097f476b329dc8ece113045668624c84b126d9a098afe699367b511dc9c495f3951a847698065b4a1725e13ad27ff61ad7a2f2ee6b00e19f463a3d9144e9d39630c7bd81ee15fad17c709e376dda5c10b9c9777c82a65bf289e06ead4339482d3f1f83c80cf23f8be8ddb3be86d0e617b8453cce533bc6df14940670489b6904ac195596a5ec2be451c381ea3af3548cffa82a331d7a9c583173aba2df2e984ae8530295a3cf8921156d858100f9a49372c93219f6f76622cc5d1348354124e9d958386a8abc34dd4ba58898d1e10d4ea5b924f5c15b199bdc5f4098239bfc818c11a3c9326c92c32877486333159df5ae47295e27a8297d4139c1883c3d7cf1eb122f220b819eab2ff81c33c3688e6ce15b74d2d986ae7a7dd3907adc8fbd91e9b491352d6e882373060eff314c78405f95566dc9b6c3cf4eb7ca00e01da145cb0daf9daeed844fa7e4667aef6b1abce51c3c27857dc956446cfdc2f175487ae2f2199862a71cdaf9e5578b4aded69d9fbeccd69de290fb2899d35a51ab8630672d241785ff195c11d8dff9ae821bbd7b82badb7d89cd8d81f58a68fbaf7d0abd5243f7995769f671d61666e59beaed3bf8513433ace28125b855347b54c55df3a7db27058f8f9065fd818b93ec30fe9db696f9c657470a2f5e172555f6c3609e20b211d1d56528ebf9f8a82e4d07679845671ef860d56f9fae1dfb1a1e6455122a3b628cfef509b201b0a055d35e67ff432f8242748ef8e9eaee490ccc4b1fddea3f2750c269350c2e223af86ce07407e324b0a2d2db0e874752e69cc1bd23b488e9ea0c69b3a1104dca6ebda277312d53303287f901eefc8b67204f3b4e257fed2a3fff2323dc4f5f1b79004c4f10294f2a9abd344b86fda715f0f0f6a0d1c745a60f640081a4da649f6534c1d0f00ed45a5426fd432f43f03679f98e0d3b53e6cba3d542d5f22e2a3bd7e4d1842adcfb415700802d593530ad0d264ebd3370cca0f21f13ca4eb2817ab5c9bf88f9cd6fc45b4da50999d2ca1253bef106d488107b9bdb33921c1868e56ba26abb64d20a0bff8e6a1dbb1e696ed8069a816355b058407875e899790414d64a7072bc9473a064749d08cb155bc4e8e252426e42bc6037e76410f51d5c0cf0db94178d69821f8b721b335d20506ad1580475937560636127b5a0aab0de98e4a04d54e961d85f54e09e607eb890a202a988115d211db3d7a74f34d0e472cfcc33ecb53b01473f13b04b807240037d19a1adf32e037e3bf85f174ae8ef9f13b379015904534b905f880eacb796990e2c381989d17f30ce459ebf2169a78756431fe87761db83b61875305170160a686b4832d0b9e91d9279a4e6f9ca98c208068a4401067c817924912906e3b5bce338e32ee0d0287aa76ff6fbec6d30059d74b4946a826ea7c2c68b697137e4ec70d4de230a6d432cacda943f04dc6291a0bd898d82ee62aa1872fa3afa12a45ab0c6adb78fb31f2c94071d4c759d47f0ee7ba696dad458723e2183fb958b0cf73540b1d51c0d098e1f06310b8d5dc9706406dd64e18568b1eba69f864b2ed80769ce76ed2a2bd53651a7fcae8223c0d5e2526d2bb600c257fc9aec49e4c95ccd9d9fb589bba40bb6155a7a8c243f489b9d470d3e5263e087582eeb4f19ef9d807d0f98f0a6f4f0161f474e56ac7ff761d51aaa93020e26718714c927416400d3073955b6c090ca525043cd47caabffdb35f187dab50b980cc798cb5c518048b39dba42c9af7b47dd69ead5874e5ab050797a006a105c5206ce69dd25509b9db9b4cecb195f5c7fabcaf61c6162a238c9b8c1e0e762e9cb358e3586bb16bf026892723cf72523c83df9f8e82bb72f436d5fe48b2574765315eeb338bbdd64d1a8b61d095fbcb3d435c2b8a047ef080ae4bfea607cbfe48117cc6f2681836d85e912a91821c3b451eaa81a0cf61c0b0bb0df7172b6a247efe02ab9329d5ba4a6aaa13169454e8d6b7aea96630f7f3a2f8b0eb56bcd15936561621e3c2c91dd48ad860e896688cc7bbec4830ef4ed5a0e482aedd48d9a55ec4ab45b2513d43d3d28931a384eac923e719b3c8dae3a59e1d390de394779ca8b81b7c47e5edcba7a8e27cd51bd86443ac1abfa66ecd784639f43073fbd334e95a7ca439ebc2bbcc96588f8c6c365877442384be22bd0bcf9203b144203b8ce1d1c609775f9991378059007593a29ccec7284b14b57ffcdd656cde1a38487723b46d657879231888a34d1e7e07df95bc74bc79c8cfc1b2980b3af91578f492fdb8fc6a5b71676497ddb1ba40a803259d61d98dcaa27d579f08c683365382f8b37266645f42eff4bb80643727bd3a482870b79a3c1109b64c38d6f84764f2c94e9a2ebdb514ceea25989a5e512f7875438fca3d82652b417892e5b9f439ae3bb6b8bac38c456c0d4363531c9fbe95814b49f8326430032d2c8f036903e1232560a115d8df98eb7266c05d2ce6f7f171f55a1c8b430e14f728cc9805d82a90ed5e8fb3efd19ca97bc47b23e15ced0f527adec935cb0cbfda9cb3e5ad299167b318b64bb2ab3d0c2867aecce7a614aff4030aa5835154575457cf32980764c550fa3bf9771b8565916f393b9bbeecaebfe804f2655e1548d9ac9562997682989756f96da52f044805a21decd503c0a0d9b7744a4c8a1da9ee11cad4a216adfd50cedccb92ccbbf0c020cc447a977bea855df470524c249440c0e3de93368d0e748ffa115842aa33cdf7d788fcfa3e2580c07091584f7277c95e8c5423486b7f1875b8744da78b1c20d65285d6bc88b54fd3d89c0e9f9014e467f640a569737eec8f2aaa45d0b06b267cb8aa634dfb66ca0957283de8859ae324c8c67f2dda32952ddaea0812e6621cf2266f7e0b78f6cc4829c573bdf5421296c3a5d424a43d5879013337c9c1823ff6b0b290490ee2438f3249c5283ffc6f05cfaba4cbb3cda0b8b013561d02c513cddc0e2a3e6dc6d2c1ad6fb4d3d3edce05f96f8351ae846f283e84f11bbdc83cd2b417970789f413f7e7b0da9f4c1ae89b75c9f421678b8418b2408fa6c4de0bd2b390dacf108eb410f8cb930d7aedfecaed9aa90da4bf3a063c92530df13ef7ae963e195c43a8ee6ec52c5996bed9c1fc46557170b5c8a81f7a4f17402738d60d4186a03c12c1c24fb78972e67e665e650108f03c03c1ccf188a34b51e2a14d0752c70ae2f9710016b60620efcbb52ad338e54e71bea1ffc24c12ea44e226bb39bc7523a231696d5e6d2d1969e5d402a488af55e635843d0df3e64015eb2ff115a6747710efbfc21b20b79f67f5738bb8a3f90b57129d8edc037a37303aec5d1233a11a5660b72ddd833440837d9c38b31b205dc3d2c1ba50a85c777014c0f5aebae8de5661d297d5341e1f8f97f9fa975aba4fa943ca75ffd7950a21d481d1426be0020f13974faae3c3acb0dab926ea08b04e8d820342fef2f91ecced047d5aa767ecaa34e5721fc2f8deb794b2ae06fd855ab3d7cba195485121185c6c47c72ffdbdb5f93ba2c2fb27edef5a7fd7c93a8541c85bb09fc4d3950ca3f2c02180fedf0528db55da079cf00c99cf494c3946475a0f2753d9f8c70f6c35c276b4e971af39643c603f89d263dfa6a897b43268c8643e187214b97fae8e7ae02f093d393b8da770b26773411037181a9b0d0d51b9a23993770a8fd10c0fe6aa7cee29b2522fce8383b46a696811e74c441a816c30dc4eed0f57049a4a7085c1c680364afff54db252b26e103bd2c8836917c972ae135a1a580537b0f608419725022121d60cd6b6d9269a5c24831ad8202d13940b303e096884425aa1f681784fc6de84fcb185f288256b50d917981a7c76d81cfd1d9dfdcf4026a9e070aa83943c40ea9ea571d47dc69e589b6f74cc3bd8d8ee19b42311c6368cbf593ec0884cd311b16486a3f441a59bcc5ea3eb81bd717d62e0ae8618a76d8d58a825d6bad5861ad047e6bd8f0932fd413e0fc7e6a08b12bd22e838e91185ee58140c406d58f2539d232df49ddede0103af81fad85e88c9d192470efcb4410c470f838615a1f360dc8803a1c083ad8eb7b07a0a53dd45be415f3f6c7ffb72a541c94adf4fec2f70b2b9f27fc1601f1216e8bb242f617ea73c06bb39dd80ac23cbe91f820c43337f7022a5cb8bdf3332465b45dcafb301d82f40669524393e3e8d5c6a10c0c624c1896b4258317e0d21ef86168beee3bd8dbc4a71d03b60c208ef9541c8fb85cb66abcd282d7c45a48d109cbf694a33693de73c4eed2e9dc99a528b60fd6b391d91dadc15f8d1029d192aa14d44abbe75b716424705feb227968ed6c9190d2512d446b623ee2a44955cb7c37a6f5b9398118a5bede540fb94ee1919c3f64192c3cdbf50f55157d9fde8b81080854331d0a190f4ab17ec02ba9cee8bfe442ee516a3e1f9106fd90df93489ba2af359a8176a772b89fc24303e0503a51b5b1dd92c6c443dcea9ec988379ef98e71e6da768d1913dccfe62607171f8d235231967041195321f5b016bb935b87d885c0ab1c5792484b647d3085b14d0bf580b2becc59905e9db47fe08cb7c3d61f64960e6f1e938e7470f456e10d881c7bf25b4e8c59266177d7dfef87776c3f9eb3c5d1b31220bbe4cc2a2c6d9a25e20160d9b3d5aa29d8d95977593c23f059f65d9ac37733cd92649ac00d19cea5304b0103644af6197e31c3663e6fc1d67d32360dcd2e4dbc315fce072664fdda803cad5569aa0b563e845f6d2e4e1ebd5a115d0e9caeb016854b84478c823086b70b55911b9e2806a24debfa52a6c2ade02f4626f7796bb0b5e20086b5d16ddd5a23f2826bee8284a55b78f062bfdbf5ca26428253ea14f1b5d2350c319049288fea30540033c84bc81d9de020270f7e0ab0b25515ad38ff43e141446f28400717bb48dda7e4cfcdf0e756e8ea3315ce7ca6f825aa953b3e274291f240d21ff71b284ca8543ef2a882b2b5b24846ddee2b66b4fa4dd084b0d1dcb1e76154914f41e1ec38dace63aa28869cd13d759dcf3db38590522338827cf278e8c48436489c5077f4bcec02e5603510301f97f8c4166be4c4335489a261c09c916a43fe38602ec604fe1a0e42d0ae2b67dca31779043be0b3700c284bfb6032491a259d2d34d6f653ded73e8ac81b93fa7512bb00c7bd565a059980fc75330078fb1d61b6198f3b54fa30931234892ad7b1d4431cfede1002cea442a31ee307ab1354ba5df94ac1947adf0777ab27e142773ed681dfd896a29981647dfee2c663b97cb55c0097ed5ac465ab4d7bdaef253dd1101e04dd048d176a7acad72dde1b05ce34d230c6ce3786b69c324c1b275a90f8812d6b0e269af1a6c10fae1cf6db4867b17a7b38cf2e1b111e487216af312ec1785fbd20eaf41663da6d71ae3c5c7b81d53cb2b531d9bf03142f8d17f5f26720363be48edb5ec998d88d2caa2277c43fbc0a347d949edec2d84467284c3c75af43850890b120286cef4e9a0ba7113c0cfff79bfb93aaedcda761b7a45563b999f55a612fe8d61ba1134a66507bf2609e975c90ab2375bb178156a15adc47532912433c1c89956cf66d1d94edcbe44017fc5062a0c0b6ee18aca048d53e4a5809429d75f6f31744090bd0e3e6529b6c568aa6d46a39971b70135a27bc860ca6a3a4baa9b35394da0864dec3b080808eab525d1d54b57a0350f6a0d3f51e1a238e55b0371b6f028a9fa29b5057d7d8b1ffb24625f8851191b045bb52c48cfb955f9c5e932305309fa86cdae5850f789cd83b6865e6d40139e1a4fb36e1a783be925ca52b853757abf4dd154e19c4867ca64b9f36a3b4dcdae9c2617c744a335bec2926c7ca54da8f14baaeb1f1acd940ed8800219f174ca65d2dc6ffdaf8bebd03baf7e99ad10633a42829a852208039d16bd2eff7386d957d7833dd423dd5e8b0c19c28916ca41d67b100bbebeb517bbd81c4f29e14fdbbec191bcf2870458048ee25407203acd2f4b120c0c2f7ee2bc419b7a4352d8c0f75bf4e73f9e810c9830d31347759366e16f8234df0b131004a64a560930a85edd0e250159e300fa088c78b87257f6c53fca35bee38c44f2381c5406253d11f2ca854194cb183eb0626417accb1c196a67769d0dd1c3c6e0015aef1a9b5aa72ad9c6ae6c0fe39544c545e71ebe367bacfce6c17ecb20cdb4722f6ab3b9986383370f1a5b5f895e64682b957a3aac7602a92ab13e0e25824d73ef6af172fa2f3747148306354b18278d8020a431e7a2c794def53853b2d627706ef181a30f4bb6edc330affbcc506ee364170e8c7676a9e961f21275fd2a7118cbf66942b13f78f0919979a556e601bc5f242a094c243b9149a99706e2a9165ca02ac899c56c58a1f5162506636a22df47a7a5270c2ae036f213c5431ea7280583791626aafa1f6df606ceab4603abcfc6da82b207e3e31b4279bfdee226e221e1f1ed33970c5c272801b1d82ed21ef397003862be0f61928bc3544920e8c0a95fc34dfe2cdfc8e8d878cf5f226f5310945e5001508ceda5e4beb44e2d90affcf5eb2947c764afdbcfe4e03a67cf28941010ee534001694a89e45ab4d2568c89ccb212a7885924f67114a7cc869194c22f22ef559479c1bc710534a55fe78ada51387eda6c168eb9ea860878ea1470b86455c93ccd26e1a336105cafb4c2403eaafcc94311dc6c540141d54b314c5f0dc63bf3445e35f27a3b8e73dab457bf74dfe21aeee863e1ff96642215288d77aa747ea0f398f85e096ecd9f5814cd2852dd090a54fdad1b8298a8f3dd1e3c37262795f85618f048644964baac41c2992d26ae8d870ef4b30bb61fe72a93ff5cc63afb9ee31da2c70ae7caa11064a30e2ac7af11845d46a117617a89107f319ba56fbec9698e37a81f2a549366bcebc16309925b391729b5b72dcc51dee16970e1bb1e5567dc7959908013e37d18081fe1107969bdad35040137ec503ba321847fd8915a8345a59a6ac59e8a1f255e3d551d0390206cc68a251a332f3b5a078d55b83912addda29b710b83ac9ebcadbda1712b661a2c9e737d62ab2f29e9dea51578d198f26c03ac4488364f6b6082dc3f8cc8ab515731935c7a4dc6d8e7ec38fcdb2c74288e4a2d6e319a84fba067d3f1fbca825481c2d7c7ecd9c21252a2726445021b2a05f470417b0e8bb2def3ca3a7e448400bc089eaf33a75387d5edb6cfda7f9d165bc84d8015fce7c40c65e8a6d625b5d1b74310faeb52a6bc57d956a334240b4ba0c5f3c41675797816208b0d5b4528510df30142036df9248c6ec158c0229fe13814aa820555529af96826f8fe8a9c79b69e2e0682999971185235e163a53cfb417ad203b6f4da28a8c22a9864b6b309f88fbcbcfef0c012f575b8afbe01ca85a2b999c0359734a9c803b9bbe0f1671587e47ce39a8dadaa49b62c016893ac99637987f8602a57858f4d57d9268cd63197603bee7e11035bf864c143b5ed5be12a2dd8efcfbaaad6c5b60b7b68c6d4d77fa9322f099f05e0edb4f9d5c6e0e079b8395e138857553e550de69c010e6eb97946333d06e46c571260fce7e14fba0663c645be9662f4d34e5cba0422a0335416672e34fe3883502a3e582439ce12fdb9e924956117cdfda018ebe36a22dbd87ff8b686f9d619e487596ce33106b4e83a249104f85eec22ead33e2a84f82d15613e52f5fb023d18f8636a349cb0308ded3e910c96332bd6965ca3c80a86c62db8014fbef3eca170bf85c8fb0e9c02821b931cc0717bf0256911adc1ab230555b6a1b57fc676261d056a757d5640357d258f69089d41e13afb4e8654656b847b2ac12f2a1e8a55e7044be33a5ae544a32ceb95ea2eec8a66d607bebf04b3b5b7c7faa712bbed83f8800c776e6e2f32cb9d44d6761d4b8bd82cdd8f0a3f262ef390bdfa4299023eff26d458bb5d2fedda79fb576ec1c02d1c7a7fa874e4eaed417783cc16c85e6ad082909eaac6f04642c26c18f19c7c3edea6c0c31a3437c5a6b6a89899fa320240332a2d86f8c8cfbc01adf6d1d933ebca9b249110959c3462f4629b9a5860ffb351b417e7d8091af3e537c299386d7468e3bf26bfe7f57e717e409b22af255938308d997325011588c53623721d5bebee1de0ab64d629654023d8f363b84ee1af01895fd823f4d7caad613e3071fa5c2a20e2ca69e071b55676aa72b988618ebf1c99e2ab5f4369f2bf192ea9e32d4bb9d036ef538bf3303d8a22872530</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> conda </tag>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C基础语法（九）指针的进阶</title>
      <link href="/C9.html"/>
      <url>/C9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="指针基础">指针基础</h2><p>指针的主题，我们在初级阶段的《指针》章节已经接触过了，我们知道了指针的概念：</p><blockquote><p>1.指针就是变量，是用来存地址的，地址是唯一标识一块内存空间<br>2.指针的大小是固定的4/8个字节（由平台决定，32位/64位）<br>3.指针是有类型的，通常类型有char、int 、short、long、float、double<br>4.指针类型决定了指针±整数的步长，指针解引用操作的时候的能够访问空间的大小<br>5.指针的运算。</p><ul class="lvl-1"><li class="lvl-2"><strong>指针±整数(==&gt;指针指向的是该地址的上一个或下一个地址）</strong></li><li class="lvl-2"><strong>指针-指针（指向同一内存空间,可得指针之间的元素个数）</strong></li><li class="lvl-2"><strong>指针的关系运算（比较地址大小）</strong></li></ul></blockquote><h2 id="字符指针">字符指针</h2><p>指针类型中存在一种字符指针<code>char*</code></p><p><b>一般使用：</b></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch= <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> *pc = &amp;ch;</span><br><span class="line">    *pc =<span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>另一种使用方式：</b></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pstr = <span class="string">&quot;hello bit.&quot;</span>;<span class="comment">//这里是把一个字符串放到pstr指针变量里了吗？</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pstr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>注：</strong></em></p><blockquote><p><strong><font color=black>(一）常量指针int const* p 和 const int* p</font></strong></p><p><b><font color=red>const 放在指针变量的 * 左边时，表示该指针所指向的数据（地址内的内容）是常量，即不能通过该指针修改所指向的数据。但p所指向的地址可以变。</font></b></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">int</span> *p = &amp;num;  <span class="comment">// 将const放在*的左边，表示所指向的数据是常量</span></span><br><span class="line">&gt;*p = <span class="number">20</span>;  <span class="comment">// 编译错误，因为p所指向的数据是常量</span></span><br><span class="line">&gt;p++;     <span class="comment">// 合法，p本身不是常量</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，p 是一个指向 num的常量指针，即不能通过 p修改 num的值。但是可以通过 p 修改其指向的地址。</p><p>注**：int const* p定义了一个指向 const int类型数据的指针变量 p，也就是说，p 所指向的数据是一个常量，不能通过 p修改其所指向的数据**。但是 p本身不是常量，可以指向其他的 const int类型数据。</p><p><strong><font color=black>(二）指针常量int* const p</font></strong></p><p><b><font color=red>const放在指针变量的*右边时，表示指针本身是常量。它指向的地址是不可改变的，但地址里的内容可以通过指针改变。</font></b></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">&gt;<span class="type">int</span> *<span class="type">const</span> p = &amp;num;  <span class="comment">// 将const放在*的左边，并且指针本身也是常量</span></span><br><span class="line">&gt;*p = <span class="number">20</span>;   <span class="comment">// 合法，可以通过p来修改所指向的数据</span></span><br><span class="line">&gt;p++;      <span class="comment">// 编译错误，因为p本身是常量，不能修改其指向的地址</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，int* const p就是一个指针常量，表示定义了一个指向 int 类型的指针变量 p，且这个指针变量是一个常量，其值(地址）不能被改变，但它所指向的 int类型数据（地址内的内容）可以被修改。</p><p><b><font color=black>总结:</font></b></p><p>一般是根据靠近原则来看，<strong>const修饰p那么就是指针本身值（即指向的地址）不变，const修饰*p那么就是指指针指向的变量值（指向的值）不变</strong></p><p><strong><font color=red>加深记忆记住三句话：</font></strong></p><ul class="lvl-1"><li class="lvl-2"><p>指针和 const 谁在前先读谁 ；</p></li><li class="lvl-2"><p>*象征着地址，const象征着内容；</p></li><li class="lvl-2"><p>谁在前面<strong>谁就不允许改变。</strong></p></li></ul></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> arr1[] = <span class="string">&quot;abcdefk&quot;</span>;</span><br><span class="line"><span class="type">char</span> arr2[] = <span class="string">&quot;abcdefk&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p1 = <span class="string">&quot;abcdefk&quot;</span>;<span class="comment">//const使变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p2 = <span class="string">&quot;abcdefk&quot;</span>;<span class="comment">//常量字符串的地址会在内存中单独开辟一个空间，地址固定，</span></span><br><span class="line"><span class="keyword">if</span> (p1 == p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;haha\n &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if (arr1 = arr2)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;hehe\n&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;haha\n&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里p1和p2指向的是一个<b><font color=red>同一个常量字符串</font></b>。C/C++会把常量字符串存储到单独的一个内存区域，当几个指针。<strong>指向同一个字符串的时候，他们实际会指向同一块内存。但是用相同的常量字符串去初始化</strong><br><strong>不同的数组的时候就会开辟出不同的内存块</strong>。所以arr11和arr2不同，p1和p2不同。  <strong>来源《剑指offer》</strong></p><h2 id="指针数组">指针数组</h2><blockquote><p><strong>预备知识：</strong></p><ul class="lvl-1"><li class="lvl-2"><p>1.&amp;arr-数组名-此时数组名不是首元素的地址–数组名表示整个数组–&amp;数组名 取出的是整个数组的地址。</p></li><li class="lvl-2"><p>2.sizeof(arr)-sizeof(数组名）-数组名表示整个数组-sizeof(数组名）计算的是整个数组的大小。</p></li><li class="lvl-2"><p>除1、2以外，<strong><font color=blue>数组名表示数组的首元素的地址</font></strong></p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span>* arr1[<span class="number">10</span>]; <span class="comment">//整形指针的数组</span></span><br><span class="line"><span class="type">char</span> *arr2[<span class="number">4</span>]; <span class="comment">//一级字符指针的数组</span></span><br><span class="line"><span class="type">char</span> **arr3[<span class="number">5</span>];<span class="comment">//二级字符指针的数组```</span></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr1[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr2[] = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr3[] = &#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> &#125;;</span><br><span class="line"><span class="type">int</span>* parr[] = &#123; arr1,arr2,arr3 &#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E4%B9%9D%E8%8A%82%20%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6/image-20230422002000521.png" alt="image-20230422002000521"></p><p><strong>指针数组用法：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr1[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr2[] = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr3[] = &#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* parr[] = &#123; arr1,arr2,arr3 &#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; <span class="number">5</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(parr[i] + j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组指针">数组指针</h2><h3 id="数组指针的定义">数组指针的定义</h3><p><strong>数组指针是指针</strong></p><blockquote><p>整形指针：int * pint; 能够指向整形数据的指针。浮点型指针：float * pf; 能够指向浮点型数据的指针。数组指针：能够指向数组的指针</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1[<span class="number">10</span>];<span class="comment">//==int* p1[10] 指针数组</span></span><br><span class="line"><span class="type">int</span> (*p2)[<span class="number">10</span>];<span class="comment">//数组指针</span></span><br><span class="line"><span class="comment">//p1, p2分别是什么？</span></span><br></pre></td></tr></table></figure><p><strong>指针数组</strong>，对于语句“int* p1[10]”，因为“[]”的优先级要比“*”要高，所以 p1 先与“[]”结合，构成一个数组的定义，数组名为 p1，而“int*”修饰的是数组的内容，即数组的每个元素。也就是说，<strong>该数组包含 10个指向 int 类型数据的指针，<strong>如图 1 所示，因此，它是</strong>一个指针数组</strong>。</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E4%B9%9D%E8%8A%82%20%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6/22201218-19ddd896ae6a45e1b61c7e3ee59b4662.jpg" alt="Attachment"></p><p>​                                                                                                                      图 1</p><p><strong>数组指针</strong>，对于语句“int(*p2)[5]”，“()”的优先级比“[]”高，“*<strong>”号和 p2 构成一个指针的定义</strong>，<strong>指针变量名为 p2</strong>，**而 int 修饰的是数组的内容，即数组的每个元素。**也就是说，<strong>p2 是一个指针，它指向一个包含 10 个 int 类型数据的数组</strong>，如图 2 所示。很显然，它是一个数组指针，<strong>数组在这里并没有名字，是个匿名数组</strong>。</p><p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E4%B9%9D%E8%8A%82%20%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6/22201218-19ddd896ae6a45e1b61c7e3ee59b4662(1).jpg" alt="Attachment"></p><p>​                                                                                                                  图 2</p><p>由此可见，</p><blockquote><p>对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，<strong>首先它是一个指针</strong>，**它指向一个数组，**也就是说它是指向数组的指针，&gt;在 32 位系统下永远占 4 字节，至于它指向的数组占多少字节，这个不能够确定，要看具体情况。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//int* p = NULL;//p是整形指针 - 指向整形的指针 - 可以存放整形的地址</span></span><br><span class="line"><span class="comment">//char* pc = NULL;//pa是字符指针 - 指向字符的指针 - 可以存放字符的地址</span></span><br><span class="line">                  <span class="comment">//数组指针 - 指向数组的指针 -可以存放数组的地址</span></span><br><span class="line"><span class="comment">//int arr[10] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//arr-首元素地址</span></span><br><span class="line"><span class="comment">//&amp;arr[0]-首元素的地址</span></span><br><span class="line"><span class="comment">//&amp;arr-数组的地址(整个数组）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>] = &amp;arr;<span class="comment">//数组的地址要存起来</span></span><br><span class="line"><span class="comment">//上面的p就是数组指针</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* arr[<span class="number">5</span>];<span class="comment">//指针数组</span></span><br><span class="line"><span class="type">char</span>* (*pa)[<span class="number">5</span>]=&amp;arr;</span><br><span class="line"><span class="comment">//*pa指针指向数组5个元素，即(*pa)[5]；而指向的数组元素类型是char*。</span></span><br><span class="line">  <span class="comment">//故取数组的地址&amp;arr写成：char* (*pa)[5]=&amp;arr； </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E4%B9%9D%E8%8A%82%20%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6/image-20230422185558143.png" alt="image-20230422185558143" style="zoom:50%;" /><h3 id="数组名VS数组名">&amp;数组名VS数组名</h3><p><strong><font color=red>&amp;arr是取的整个数组的地址</font></strong></p><h3 id="数组指针用法">数组指针用法</h3><h4 id="用法1：">用法1：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>(*pa)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*pa+i));<span class="comment">//*pa==arr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用法2-地址传参">用法2:地址传参</h4><p><strong>二维数组看作一维数组，则其数组名就是首元素的地址</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arr[i] == *(a+i) == *(p+i) ==  p[i]</span><br><span class="line">  </span><br><span class="line">*(*(p + i) + j)== *(p[i] + j)==(*(p + i))[j]==p[i][j]</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*(p + i) + j);<span class="comment">//(p + i)找到n维数组第i行的地址，(*(p + i) + j)找到n维数组第i行的第j列元素的地址</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是数组的形式</span></span><br><span class="line"><span class="comment">//void print1(int arr[3][5], int x, int y)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">////int i = 0, j = 0;</span></span><br><span class="line"><span class="comment">////for (i = 0;i &lt; x;i++)</span></span><br><span class="line"><span class="comment">////&#123;</span></span><br><span class="line"><span class="comment">////for (j = 0;j &lt; y;j++)</span></span><br><span class="line"><span class="comment">////&#123;</span></span><br><span class="line"><span class="comment">////printf(&quot;%d &quot;, arr[i][j]);</span></span><br><span class="line"><span class="comment">////&#125;</span></span><br><span class="line"><span class="comment">////printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">////&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是指针的形式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> (*p)[<span class="number">5</span>], <span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//int (*p)[5] - 数组指针p是指向含5个元素为int类型的数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; x;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; y;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i][j]);</span><br><span class="line"><span class="comment">//printf(&quot;%d &quot;, *(p[i] + j));</span></span><br><span class="line"><span class="comment">//printf(&quot;%d &quot;, * (*(p + i) + j));//(p + i)找到n维数组第i行的地址，(*(p + i) + j)找到n维数组第i行的第j列元素的地址</span></span><br><span class="line"><span class="comment">//printf(&quot;%d &quot;, (*(p + i))[j]);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#125;;</span><br><span class="line"><span class="comment">//print1(arr, 3, 5);//arr - 数组名 -数组名就是首元素的地址</span></span><br><span class="line">print2(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//数组名arr，表示首元素的地址</span></span><br><span class="line">    <span class="comment">//但是二维数组的首元素是二维数组的第一行</span></span><br><span class="line">    <span class="comment">//所以这里传递的arr，其实相当于第一行的地址，是一维数组的地址</span></span><br><span class="line">    <span class="comment">//可以数组指针来接收</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//int arr[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;</span></span><br><span class="line"><span class="comment">//int i = 0;</span></span><br><span class="line"><span class="comment">//int* p = arr;</span></span><br><span class="line"><span class="comment">//for (i = 0;i &lt; 10;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">////printf(&quot;%d &quot;, *(p + i));</span></span><br><span class="line"><span class="comment">////printf(&quot;%d &quot;,p[i]);</span></span><br><span class="line"><span class="comment">////printf(&quot;%d &quot;, *(arr + i));</span></span><br><span class="line"><span class="comment">//printf(&quot;%d &quot;, arr[i]);//arr[i] == *(a+i) == *(p+i) ==  p[i]</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];<span class="comment">//arr是一个含5个元素的整形数组</span></span><br><span class="line"><span class="type">int</span> *parr1[<span class="number">10</span>];<span class="comment">//parr1是一个数组，数组有10个元素，每个元素的类型是int*,故parr1是指针数组</span></span><br><span class="line"><span class="type">int</span> (*parr2)[<span class="number">10</span>];<span class="comment">//parr2是数组指针，它指向一个含10个元素的数组，数组的元素类型是int</span></span><br><span class="line"><span class="type">int</span> (*parr3[<span class="number">10</span>])[<span class="number">5</span>];<span class="comment">//parr3是数组，该数组的有10个元素，每个元素是一个数组指针；该数组指针指向的数组有5个元素，每个元素类型是int</span></span><br></pre></td></tr></table></figure><h3 id="数组参数、指针参数">数组参数、指针参数</h3><h4 id="一维数组传参">一维数组传参</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[])</span><span class="comment">//ok</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[<span class="number">10</span>])</span><span class="comment">//ok</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> *arr)</span><span class="comment">//ok</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> *arr[<span class="number">20</span>])</span><span class="comment">//ok</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> **arr)</span><span class="comment">//ok//一级指针的地址存放在二级指针里 int **arr</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *arr2[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">    test2(arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维数组传参">二维数组传参</h4><p><strong>二维数组的数组名是首元素的地址，传参时，传入的是<font color=red>数组第一行地址</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>])</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> arr[][<span class="number">5</span>])</span><span class="comment">//数组传参，行可以省略，列不可以省略</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> arr[][])</span><span class="comment">//error</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test3</span><span class="params">(<span class="type">int</span> *arr)</span><span class="comment">//error,二维数组无法存放整形指针中去</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test4</span><span class="params">(<span class="type">int</span>** arr)</span><span class="comment">//error,数组名是第一行地址，而二级指针存放是一级变量（指针）的地址</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">//总结：二维数组传参，函数形参的设计只能省略第一个[]的数字。</span></span><br><span class="line"><span class="comment">//因为对一个二维数组，可以不知道有多少行，但是必须知道一行多少元素。</span></span><br><span class="line"><span class="comment">//这样才方便运算。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test5</span><span class="params">(<span class="type">int</span>* arr[<span class="number">5</span>])</span><span class="comment">//ok？//error</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test6</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">5</span>])</span><span class="comment">//ok？//ok</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一级指针传参">一级指针传参</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = arr;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//一级指针p，传给函数</span></span><br><span class="line">    print(p, sz);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考：</strong></p><blockquote><p>当一个函数的参数部分为一级指针的时候，函数能接收什么参数？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> *p)</span></span><br><span class="line">  &#123;&#125;</span><br><span class="line"><span class="comment">//test1函数能接收什么参数？  test1(&amp;a);或test1(p1);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span>* p1=&amp;a;</span><br><span class="line">  test1(&amp;a);</span><br><span class="line">  test1(p1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">char</span>* p)</span></span><br><span class="line">   &#123;&#125;</span><br><span class="line"><span class="comment">//test2函数能接收什么参数？  test2(&amp;ch);或test2(str);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; <span class="type">char</span> ch=<span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">  <span class="type">char</span>* str=&amp;ch;</span><br><span class="line">  test2(&amp;ch);</span><br><span class="line">  test2(str);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="二级指针传参">二级指针传参</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>** ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, **ptr);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;n;</span><br><span class="line">    <span class="type">int</span> **pp = &amp;p;<span class="comment">//取一级指针p的地址</span></span><br><span class="line">    test(pp);</span><br><span class="line">    test(&amp;p);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span>* arr[<span class="number">10</span>];<span class="comment">//指针数组，数组里每个元素都是一级指针</span></span><br><span class="line">  test(arr);<span class="comment">//传过去的是arr数组首元素的地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：</p><blockquote><p>当函数的参数为二级指针的时候，可以接收什么参数？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> **p)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="type">char</span> c = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">   <span class="type">char</span>*pc = &amp;c;</span><br><span class="line">   <span class="type">char</span>**ppc = &amp;pc;</span><br><span class="line">   <span class="type">char</span>* arr[<span class="number">10</span>];<span class="comment">//指针数组，数组里每个元素都是一级指针</span></span><br><span class="line">   test(&amp;pc);</span><br><span class="line">   test(ppc);</span><br><span class="line">   test(arr);<span class="comment">//Ok?//ok//传过去的是arr数组首元素的地址</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="函数指针">函数指针</h2><p><strong>&amp;函数名 和 函数名 都是函数的地址</strong></p><p>函数指针定义示例：</p><pre><code>int Add(int x, int y)&#123;&#125;int (*pa)(int ,int ) = Add;printf(&quot;%d\n&quot;, (*pa)(2, 3));</code></pre><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数指针 - 是指向函数的指针 -存放函数地址的指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> z = x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">/*printf(&quot;%d &quot;, Add(a, b));*/</span></span><br><span class="line"><span class="comment">//&amp;函数名 和 函数名 都是函数的地址</span></span><br><span class="line"><span class="comment">//printf(&quot;%p\n&quot;, &amp;Add);//打印出函数的地址</span></span><br><span class="line"><span class="comment">//printf(&quot;%p\n&quot;, Add);//打印出函数的地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*pa)(<span class="type">int</span> ,<span class="type">int</span> ) = Add;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*pa)(<span class="number">2</span>, <span class="number">3</span>));<span class="comment">//5</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> (*p)(<span class="type">char</span>*) = Print;</span><br><span class="line">(*p)(<span class="string">&quot;hello bit&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>课件：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面pfun1和pfun2哪个有能力存放test函数的地址？</span></span><br><span class="line"><span class="type">void</span> (*pfun1)();</span><br><span class="line"><span class="comment">//pfun1可以存放。pfun1先和*结合，说明pfun1是指针，指针指向的是一个函数，指向的函数无参数，返回值类型为void。</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pfun2</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//pfun2表明这是一个函数，其返回类型是void*</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语法 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C基础语法（八）数据的存储</title>
      <link href="/C8.html"/>
      <url>/C8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数据类型详细介绍">数据类型详细介绍</h2><p><strong>内置类型</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>    <span class="comment">//字符数据类型</span></span><br><span class="line"><span class="type">short</span>    <span class="comment">//短整型</span></span><br><span class="line"><span class="type">int</span>     <span class="comment">//整形</span></span><br><span class="line"><span class="type">long</span>    <span class="comment">//长整型</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span>  <span class="comment">//更长的整形</span></span><br><span class="line"><span class="type">float</span>    <span class="comment">//单精度浮点数</span></span><br><span class="line"><span class="type">double</span>   <span class="comment">//双精度浮点数</span></span><br></pre></td></tr></table></figure><p>int 和float都是占内存4个字节，但是在内存中存储形式不同</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/第八节 数据的存储/image-1.png" style="zoom: 67%;" /><p><strong>自定义类型（构造类型）</strong>—略，后面会讲。</p><h3 id="类型的基本归类：">类型的基本归类：</h3><p><strong>整形家族：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span><span class="comment">//在内存中以Ascall码存储的</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span></span><br><span class="line"><span class="type">short</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> [<span class="type">int</span>]</span><br><span class="line">    <span class="type">signed</span> <span class="type">short</span> [<span class="type">int</span>]</span><br><span class="line"><span class="type">int</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span></span><br><span class="line"><span class="type">long</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> [<span class="type">int</span>]</span><br><span class="line">    <span class="type">signed</span> <span class="type">long</span> [<span class="type">int</span>]</span><br></pre></td></tr></table></figure><p><strong>浮点型家族</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span></span><br><span class="line"><span class="type">double</span></span><br></pre></td></tr></table></figure><p><strong>构造类型：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; 数组类型</span><br><span class="line">&gt; 结构体类型 <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&gt;</span> 枚举类型 <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&gt;</span> 联合类型 <span class="class"><span class="keyword">union</span></span></span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680841072601-18.png" /><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//无类型，此时在main中输入100是错误的</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        test(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整形在内存中的存储：">整形在内存中的存储：</h2><h3 id="原码、反码、补码">原码、反码、补码</h3><p>计算机中的<font color=Red><strong>整数（有符号数）</strong></font>有三种表示方法，即原码、反码和补码。</p><p>三种表示方法均有<strong>符号位和数值位</strong>两部分，符号位都是<strong>用0表示“正”，用1表示“负”</strong>，</p><p><strong>无符号数原码、反码、补码都相同</strong></p><p><strong>正数的原、反、补码都相同。</strong></p><p>而数值位<strong>负数的三种表示方法各不相同</strong>。如下：</p><table><thead><tr><th style="text-align:left"><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680842673110-7.png" align="left" /></th></tr></thead><tbody><tr><td style="text-align:left"><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680842677026-9.png" align="left" /></td></tr><tr><td style="text-align:left"><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680842682081-11.png" style="zoom:67%;" align="left"/></td></tr></tbody></table><p><strong>对于整形来说：数据存放内存中其实存放的是补码。</strong></p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680843045650-13.png" /><h3 id="二进制与八进制、十六进制转化规则">二进制与八进制、十六进制转化规则</h3><p><strong>十六进制与二进制转化规则：“8421”原则，即4个二进制位构成1个十六进制位，并按照“8421”原则转化</strong></p><p><strong>八进制与二进制转化规则：“421”原则，即3个二进制位构成1个八进制位，并按照“421”原则转化</strong></p><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">20</span>;<span class="comment">//4个字节-32bit</span></span><br><span class="line">        <span class="comment">//00000000 00000000 00000000 00010100-原码</span></span><br><span class="line">        <span class="comment">//00000000 00000000 00000000 00010100-反码</span></span><br><span class="line">        <span class="comment">//00000000 00000000 00000000 00010100-补码</span></span><br><span class="line">        <span class="comment">//0X0014</span></span><br><span class="line">        <span class="type">int</span> b = <span class="number">-10</span>;</span><br><span class="line">        <span class="comment">//10000000 00000000 00000000 00001010-原码</span></span><br><span class="line">        <span class="comment">//11111111 11111111 11111111 11110101-反码</span></span><br><span class="line">        <span class="comment">//11111111 11111111 11111111 11110110-补码</span></span><br><span class="line">        <span class="comment">//0XFFFFFFF6</span></span><br><span class="line">        <span class="comment">//内存中存的是整数的补码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大小端字节序介绍及判断">大小端字节序介绍及判断</h3><p>对于a和b分别存储的是补码。但是我们发现存储到内存后顺序有点不对劲</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/%E7%AC%AC1%E8%8A%82-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8.png" style="zoom:50%;"/><h4 id="大小端介绍">大小端介绍</h4><p><strong>什么大端小端：</strong></p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680844912666-16.png" /><p><strong>大端正着存数据，小端倒着存数据。</strong></p><p><em>编译器支持大端存储或者小端存储模式</em></p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680846416559-18.png" style="zoom:60%;" /><p>**例：**写一段代码告诉我们当前机器的字节序是什么？</p><p><em>char</em>类型访问一个字节的地址*</p><p><strong>//指针类型的意义：</strong></p><p>1.指针类型决定了指针解引用操作符能访问几个字节：<code>char*</code>能访问1个字节，<code>int*</code>能访问4个字节</p><p>2.指针类型决定了指针+1、-1，能加或者能减的是几个字节；<code>char*p,p+1跳过1个字节</code>；<code>int*p,p+1:跳过4个字节</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回1 小端存储</span></span><br><span class="line"><span class="comment">//返回0 大端存储</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check_sys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>*p=(<span class="type">char</span>*)&amp;a;<span class="comment">//将&amp;a类型从int*强制转换为char*,方便指针p调用</span></span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = check_sys();<span class="comment">//将&amp;a类型从int*强制转换为char*,方便指针p调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret== <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端存储\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端存储\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习">练习</h3><h4 id="例1："><strong>例1：</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//-1-char类型 占1个字节即8个比特位</span></span><br><span class="line">    <span class="comment">//10000001-原码</span></span><br><span class="line">    <span class="comment">//11111110-反码</span></span><br><span class="line">    <span class="comment">//11111111-补码</span></span><br><span class="line">    <span class="type">char</span> a = <span class="number">-1</span>;<span class="comment">//char-字符类型 占1个字节</span></span><br><span class="line">    <span class="comment">//11111111-补码---&gt;-1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> b = <span class="number">-1</span>;<span class="comment">//signed符号数</span></span><br><span class="line">    <span class="comment">//11111111-补码---&gt;-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">-1</span>;<span class="comment">//unsigned-无符号数</span></span><br><span class="line">    <span class="comment">//11111111-补码、原码-----&gt;255</span></span><br><span class="line">    <span class="comment">//类型提升：从有符号数(char)转换为无符号数(unsigned char)，最高位转为无符号位。</span></span><br><span class="line">    <span class="comment">//此时由于unsigned存在，整型直接将有符号位转换为无符号位</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d,c=%d&quot;</span>, a, b, c);<span class="comment">//%d-整型，此时会发生类型提升</span></span><br><span class="line">    <span class="comment">//-1 -1 255</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，变量c是一个无符号的char类型，其取值范围为0到255。当将有符号的-1赋给无符号的变量c时，<strong>由于无符号数不支持负数，编译器会先将-1转换为其对应的无符号整数表示方式</strong>，即<strong>将有符号数的补码转换为无符号数的值</strong>。</p><p>在8位(char)情况下，-1的补码为11111111，将其转换为无符号整数后，其值为2^8 - 1 = 255。因此，当用printf函数并指定格式化字符串为&quot;%d&quot;时，输出的结果为c=255，对应于二进制表示为11111111。</p><h4 id="例2："><strong>例2：</strong></h4><p><strong>//<font color=Red>类型提升：从有符号数(char)转换为无符号数（unsigned int)，补位须与最高位相同。</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">-128</span>;</span><br><span class="line">    <span class="comment">//10000000-原码</span></span><br><span class="line">    <span class="comment">//11111111-反码</span></span><br><span class="line">    <span class="comment">//10000000-补码（8位）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, a);<span class="comment">//%u-打印十进制的无符号数，</span></span><br><span class="line">    <span class="comment">//%u将a从有符号字符(char)转换为无符号数（unsigned int)，补位须与最高位相同。</span></span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 10000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char类型确实只占8位，但在这段代码中，使用**%u格式说明符时将变量a强制转换为无符号整数(unsigned int)类型。通常情况下，unsigned int类型在大多数系统架构中都是占用32位的内存空间。**</p><p>因此，当a的值为-128时，其在内存中的二进制补码表示为10000000。**按照%u格式说明符进行输出时，编译器会先将其强制转换为一个32位的无符号整数(unsigned int)，补齐高位后输出其二进制表示。**因此输出的结果为11111111 11111111 11111111 10000000的二进制表示，对应于4294967168这个十进制无符号整数。</p><h4 id="注：">注：</h4><p><strong><font color=Red>signed char(有符号字符）类型范围是-128~127，超过127自动转化为-128直到转化到0，再从0开始累计</font></strong></p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680848507527-22.png" style="zoom:50%;" /><p><strong><font color='red'>unsigned char(无符号字符)类型范围是0~225，超过225自动转化为0，再开始累计</font></strong></p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680848316815-20.png" style="zoom:67%;" /><h4 id="例3："><strong>例3：</strong></h4><p><strong>//<font color='red'>signed char（有符号字符）类型最大只能存入01111111（127）当超过之后，就会变成127+1变成-128了，不溢出。</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123; <span class="type">char</span> a = <span class="number">128</span>; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, a); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//signed char（无符号字符）类型最大只能存入01111111（127）当超过之后，就会变成127+1变成-128了，不溢出。  </span></span><br></pre></td></tr></table></figure><h4 id="例4："><strong>例4：</strong></h4><p><strong>//<font color='red'>有符号和无符号一起计算时，首先按照补码的形式进行运算，最后格式化成为有符号数</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">-20</span>;</span><br><span class="line">    <span class="comment">//10000000 00000000 00000000 00010100</span></span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 11101011</span></span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 11101100-补码</span></span><br><span class="line">                                </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//00000000 00000000 00000000 00001010</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + b);</span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 11101100-a</span></span><br><span class="line">    <span class="comment">//00000000 00000000 00000000 00001010-b</span></span><br><span class="line">    <span class="comment">//11111111 11111111 11111111 11110110-a+b---&gt;-10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例5："><strong>例5：</strong></h4><p>**//<font color='red'> unsigned int i; 其中i为无符号数，无论i含不含负数，都认为是无符号数。此时会将其补码视为无符号数真实值，即i始终大于等于0 </font>**下列代码中会陷入死循环。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, i);</span><br><span class="line">        Sleep(<span class="number">1000</span>);<span class="comment">//睡眠代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例6：">例6：</h4><p><strong>signed</strong> **char(有符号字符）的范围是-128<sub>127，当char数组存入int元素时,会将其转换为char类型**，由此，下列代码中存入到char数组的元素经历了从-1</sub>-128<sub>127</sub>0转化，而char字符0表示的是‘\0’，故最终计算字符串长度为255.</p><p><strong>注：</strong> <strong>//<font color=red>int类型占4个字节，不代表i会占4个字节！！！不要陷入误区。</font></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//int类型占4个字节，不代表i会占4个字节！！！</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="number">-1</span>-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">strlen</span>(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例7">例7:</h4><p>**<font color=red>unsigned char(无符号字符）的范围是0~225，当超过225后自动转为0重新累计到225；</font>**下列代码因此陷入死循环。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;<span class="comment">//0~225</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;=<span class="number">255</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//陷入死循环</span></span><br></pre></td></tr></table></figure><h2 id="浮点型在内存中的存储">浮点型在内存中的存储</h2><p><strong>常见的浮点数：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159</span></span><br><span class="line"><span class="number">1E10</span></span><br><span class="line">浮点数家族包括：<span class="type">float</span>、<span class="type">double</span>、<span class="type">long</span> <span class="type">double</span>类型。</span><br><span class="line">浮点数表示的范围：<span class="type">float</span>.h</span><br></pre></td></tr></table></figure><h3 id="一个例子">一个例子</h3><p>浮点数存储的例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="type">float</span> *pFloat = (<span class="type">float</span> *)&amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为：%d\n&quot;</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);</span><br><span class="line"></span><br><span class="line">    *pFloat = <span class="number">9.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num的值为：%d\n&quot;</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/Image-1680849776251-24.png" style="zoom:33%;"  /><h3 id="浮点数存储规则">浮点数存储规则</h3><p>根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：</p><table><thead><tr><th style="text-align:left">(-1)^S * M * 2^E                                                                                                                             (-1)^s 表示符号位，当s=0，V为正数；当s=1，V为负数。                                                         M表示有效数字，1≤M&lt;2。                                                                                                                    2^E表示指数位。</th></tr></thead></table><h4 id="IEEE-754规定：">IEEE 754规定：</h4><p>对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407162229299.png" style="zoom:50%;" /><p>对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407162359787.png" style="zoom:50%;" /><h5 id="IEEE-754-font-color-red-一些特别规定-font-：">IEEE 754<font color=red>一些特别规定</font>：</h5><p><strong><font color=blue>有效数字M情况：</font></strong></p><p>**在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，<strong>等到读取的时候，再把第一位的1加上去</strong>。这样做的目的，是节省1位有效数字。<strong>以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字</strong>。</p><p><strong><font color=blue>指数E情况：</font></strong></p><div style="text-align: justify;font-size:16px;">E为一个无符号整数（unsigned int）如果E为8位，它的取值范围为0~225；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。</div><p><strong>例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">5.5</span>;</span><br><span class="line">    <span class="comment">//5.5---101.1</span></span><br><span class="line">    <span class="comment">//(-1)^0*1.011*2^2</span></span><br><span class="line">    <span class="comment">//S=0;M=1.011;</span></span><br><span class="line">    <span class="comment">//E=2;</span></span><br><span class="line">    <span class="comment">//S  E+127    M</span></span><br><span class="line">    <span class="comment">//0 10000001  01100000000000000000000</span></span><br><span class="line">    <span class="comment">//0100 0000 1011 0000 0000 0000 0000 0000</span></span><br><span class="line">    <span class="comment">//0X40b00000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//最终在内存里为小端存储</span></span><br></pre></td></tr></table></figure><h4 id="指数E从内存中取出分三种情况">指数E从内存中取出分三种情况</h4><p><strong>1.E不全为0或不全为1</strong></p><p>这时，浮点数就采用下面的规则表示，<strong>即指数E的计算值减去127（或double类型是1023），得到真实值，再将有效数字M前加上第一位的1。</strong></p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407173256948.png" style="zoom:80%;" /><p><strong>2.E全为0(即为-127时)</strong></p><p>这时，<strong>浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数</strong>。这样做是为了表示±0以及接近于0的很小的数字</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407173856180.png" style="zoom:80%;" /><p><strong>3.E全为1</strong></p><p>这时，<strong>如果有效数字M全为0，表示±无穷大</strong>(数字很大）（正负取决于符号位s）</p><img src="https://cdn.staticaly.com/gh/AnZhiJJ/Blog_Img@C/%E7%AC%AC%E5%85%AB%E8%8A%82%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/image-20230407174114862.png" style="zoom:80%;" /><p><strong>解释例子（看其中解释）：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">  <span class="comment">//00000000 00000000 00000000 00001001-补码</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span>* pFloat = (<span class="type">float</span>*)&amp;n;<span class="comment">//此时*pFloat可以指向int所占的4个字节空间，但是指针只能一个字节一个字节的访问空间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;n的值：%d\n&quot;</span>, n);<span class="comment">//9</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*pfloat的值为：%f\n&quot;</span>, *pFloat);<span class="comment">//此时*pFloat会认为其n为浮点数,会对其二进制按照浮点数来排列(S E+127 M)输出</span></span><br><span class="line">  <span class="comment">//首先，将9拆分，得到第一位符号位s=0，后面8位的指数E=00000000，最后23位的有效数字M = 000 0000 0000 0000 0000</span></span><br><span class="line">  <span class="comment">//由于指数E全为0，所以符合上一节的第二种情况。因此，浮点数V就写成：</span></span><br><span class="line">  <span class="comment">//(-1)^0 * 0.00000000000000000001001 * 2^-126</span></span><br><span class="line">  <span class="comment">//V是一个很小的接近于0的正数，所以用十进制小数表示打印出来0.000000</span></span><br><span class="line"></span><br><span class="line">  *pFloat = <span class="number">9.0</span>;</span><br><span class="line">  <span class="comment">//1001.0--9.0的补码</span></span><br><span class="line">  <span class="comment">//1.001*2^3 #S=0 , M=1.001 , E=3---011</span></span><br><span class="line">  <span class="comment">//E+127---10000010</span></span><br><span class="line">  <span class="comment">// S      E+127         M(23bit)</span></span><br><span class="line">  <span class="comment">//(-1)^0 * 10000010 * 00100000000000000000000 ---浮点数在内存表现形式</span></span><br><span class="line">  <span class="comment">//0 10000010 00100000000000000000000 </span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;num的值：%d\n&quot;</span>, n);<span class="comment">//此时n将*pFloat存进去认为是整数，会对其二进制按照整数来排列输出。即</span></span><br><span class="line">  <span class="comment">//01000001 00010000 00000000 00000000</span></span><br><span class="line">  <span class="comment">//0x41 10 00 00--十六进制</span></span><br><span class="line">  <span class="comment">//1091567616--十进制</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>, *pFloat);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
